#############################################################################
#
#   oflobjs.gsl - Stored Procedure for OFL object handlers
#
#############################################################################

#############################################################################
function generate_stored_procedures
#############################################################################
  echo "Generating stored procedures for SQLServer..."
  output "storeproc.xml"
  ><storeproc unicode = "$(unicode)">
  for root.dfl
    for root.ofl
      set_sql_target ("mssql")
      if unicode ?= 1
        dfl.longtext_limit = 4000
      endif
      for object where build
        object.handler ?= root_table
        do_stored_proc_inherit   ()
        do_stored_proc_create    ()
        do_stored_proc_update    ()
        do_stored_proc_fetch     ()
        do_stored_proc_query     ()
        do_stored_proc_delete    ()
        do_stored_proc_subselect ()
      endfor object
    endfor ofl
  endfor dfl
  ></storeproc>
  close
endfunction


#############################################################################
function create_stored_proc_param (value, param_type, cmd_append)
#############################################################################
#   Set Direction of paramter
    param_size = ""
    if    param_type = "OUT"
        param_dir = "adParamOutput"
    elsif param_type = "INOUT"
        param_dir = "adParamInputOutput"
    elsif param_type = "RETURN"
        param_dir = "adParamReturnValue"
    else
        param_dir = "adParamInput"
    endif
#   Set type and size

vb_type = sp_type_varchar
if !defined (field.size)
    param_size = 30
else
    if field.size > dfl.longtext_limit
        vb_type = sp_type_lvarchar
    endif
    param_size = field.size
endif
if unicode ?= 1
    if param_size = 8000
        param_size = 4000
    endif
#>    On Error Resume Next
#>    If Not IsNull ($(value:)) Then
#>        string_value = $(value:)
#>    Else
#>        string_value = ""
#>    End If 
#>    string_size = $(param_size + 1)
>    Set Param = Cmd$(cmd_append).CreateParameter ("$(field.name:)",  $(vb_type:),  $(param_dir:),  $(param_size + 1), $(value:))
else
>    Set Param = Cmd$(cmd_append).CreateParameter ("$(field.name:)",  $(vb_type:),  $(param_dir:),  $(param_size), $(value:))
endif
>    Cmd$(cmd_append).Parameters.Append Param
endfunction

#############################################################################
.macro stored_head (func_name, comment)
.#############################################################################
<procedure name = "$(func_name:)" text = "
.    if defined (comment)
/* $(comment:)                                                               */
.    endif

CREATE PROCEDURE $(func_name:)
.endmacro

#############################################################################
.macro stored_footer (func_name)
.#############################################################################
    SET NOCOUNT OFF"
/>
.endmacro

.#############################################################################
.macro do_stored_proc_fetch
.#############################################################################
.    for view where defined (fetch_view)
.        for table 
.#           Add timestamp in fetch view for OAL revised value
.            for dfl.table as dbtable where dbtable.name = table.name
.              for dbtable.field as dbfield where count (rule, when = "update" & name = "timestamp")
.                if count (table.field, name = dbfield.name) = 0
.                  copy dbfield to table
.                  for table.field as dfield where name = dbfield.name
.                    dfield.add4fetch  = 1
.                    dfield.calculated = 0
.                    dfield.size       = dbfield.size?30
.                  endfor
.                endif
.              endfor
.              for dbtable.rule where name = "soft delete"
.                for dbtable.field as dbfield where name = rule.what
.                    table.have_active = dbfield.realname
.                endfor
.              endfor
.            endfor
.            make_table_select ()
.            set_field_target_type ()
.            fct_name = "$(object.name)_fetch_$(view.name)"
.            stored_head (fct_name, \
                          "Procedure used in object $(object.name) to fetch view $(view.name)")
.            comma = " "
.            for field where count (index, name = "primary")
.                param_type = type_sql_varchar
.                if !defined (size)
.                    field.size = 30
.                endif
    $(comma)@$(field.name:) $(param_type) ($(size))
.            comma = ","    
.            endfor
AS
    SET NOCOUNT ON
    SET LOCK_TIMEOUT 60
.   make_table_select ()
    SELECT $(select) FROM $(realname) WHERE
.            comma = "    "
.            for field where count (index, name = "primary")
.               if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
        $(comma)$(field.realname:) = @$(field.name)
.               else
        $(comma)$(field.realname:) = CAST (@$(field.name:) As $(target_type:))
.               endif
.                comma = " AND "    
.            endfor
.            if defined (table.have_active)
         AND $(table.have_active:) = 1
.            endif
.            stored_footer (fct_name)
.#######################################
.#       Resolve child and lookup link #
.#######################################
.            for field where calculated ?= 0
.                for table
.                  for dfl.table as dbtable where dbtable.name = table.name
.                    for dbtable.rule where name = "soft delete"
.                      for dbtable.field as dbfield where name = rule.what
.                        table.have_active = dbfield.realname
.                      endfor
.                    endfor
.                  endfor
.                    fct_name = "$(object.name)_fetch_$(view.name)_$(field.realname)_$(table.name)"
.                    stored_head (fct_name, \
                                  "Procedure used in object $(object.name) to fetch lookup or child $(field.realname) in view $(view.name)")
.                    param_type = type_sql_varchar
.                    if !defined (size)
.                        size = 30
.                    endif
    @$(field.name:) $(param_type) ($(size))
AS
    SET NOCOUNT ON
.   make_table_select ()   
    SELECT $(select) FROM $(table.realname) WHERE
.               if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
        $(target) = @$(field.name)
.               else
        $(target) = CAST (@$(field.name:) As $(target_type:))
.               endif
.               if defined (table.have_active)
        AND $(table.have_active:) = 1
.               endif
.                    stored_footer (fct_name)
.                endfor
.            endfor
.        for table.field as tmpfield where defined (add4fetch)
.           delete tmpfield
.        endfor
.        endfor
.    endfor
.endmacro

##############################################################################
.macro do_stored_proc_inherit
.##############################################################################
.for inherit
.    set_field_target_type ()
.    fct_name = "$(object.name)_inherit_from_$(inherit.table)"
.    stored_head (fct_name, \
                  "Procedure used in object $(object.name) to get inherited fields from $(inherit.table)")
.  comma = ""
.  param_type = type_sql_varchar
.  for field
.     if !defined (size)
.         field.size = 30
.     endif
    $(comma)@$(FIELD.TARGET) $(param_type) ($(size))  OUTPUT
.     comma = ","
.  endfor
.  for link
.    set_field_target_type ()
.    for field
.     if !defined (size)
.         field.size = 30
.     endif
.     if field.type = "textual" & field.size >= dfl.longtext_limit & unicode ?= 1
.         field.size = 4000
.     endif
    $(comma)@$(FIELD.REALNAME) $(param_type) ($(size))
.     comma = ","
.    endfor
.  endfor
AS
    SET NOCOUNT ON
    DECLARE @feedback                    integer
    DECLARE @$(object.name)_inherit_cur  CURSOR

    SET  @$(object.name)_inherit_cur = CURSOR LOCAL FOR SELECT 
.  comma = "  "
.  for field
        $(comma)$(realname)
.       comma = ", "
.  endfor
        FROM $(inherit.table_realname) WHERE 
.   for link
.     comma = "    "
.     for field
.       if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
        $(comma)$(target_realname) = @$(REALNAME)
.       else
        $(comma)$(target_realname) = CAST (@$(REALNAME) As $(target_type))
.       endif
.       comma = "AND "
.     endfor
.   endfor

    OPEN @$(object.name)_inherit_cur
    FETCH NEXT FROM @$(object.name)_inherit_cur
    INTO
.   comma = ""
.   for field
        $(comma)@$(FIELD.TARGET)
.       comma = ", "
.   endfor

    IF @@FETCH_STATUS = 0
        Set @feedback = 1
    ELSE
        Set @feedback = 0
    CLOSE      @$(object.name)_inherit_cur
    DEALLOCATE @$(object.name)_inherit_cur
    RETURN @feedback
.    stored_footer (fct_name)
.endfor
.endmacro
 
##############################################################################
function do_stored_proc_create
##############################################################################
  for view where name = "create"
    for table
      generate_create_sp ()
    endfor
  endfor
endfunction

.-  This macro creates a Stored procedure to create table and all child tables.

##############################################################################
.macro generate_create_sp ()
.##############################################################################
.## ADD all field needed by insert rule into the view
.  for dfl.table as dbtable where dbtable.name = table.name
.    for dbtable.field as dbfield where count (rule, when = "insert")
.      if count (table.field, name = dbfield.name) = 0
.        copy dbfield to table
.          for table.field as dfield where name = dbfield.name
.              dfield.add4create = 1
.              dfield.calculated = 0
.              dfield.size       = dbfield.size?30
.          endfor
.      endif
.    endfor
.  endfor

.    if table.type = "root"
.        fct_name = "$(object.name)_create"
.    else
.        fct_name = "$(object.name)_create_$(view.name)_$(table.name)_$(table.target)"
.    endif
.    set_field_target_type ()
.    recordid = ""
.    stored_head (fct_name, \
                  "Procedure used in object $(object.name) to create")
.    comma = " "     
.    timestamp_field = ""
.    for field where calculated ?= 0
.       if count (rule, when = "insert") > 0
.           for rule where when = "insert"
.               if rule.name = "userid"
    $(comma)@$(field.name:) $(type_sql_varchar:) (9)
.               elsif name = "recordid"
    $(comma)@$(field.name:) $(type_sql_varchar:) (9) OUTPUT
.                   recordid      = field.name
.                   real_recordid = field.realname
.               elsif name = "timestamp"
.   timestamp_field = field.name 
    $(comma)@$(field.name:) $(type_sql_varchar:) (30) OUTPUT
.               endif
.           endfor
.       else
.           param_type = type_sql_varchar
.           if !defined (size)
.               field.size = 30
.           endif
.           if field.type = "textual" & field.size >= dfl.longtext_limit & unicode ?= 1
.             field.size = 4000
.           endif
    $(comma)@$(field.name:) $(param_type) ($(size))
.       endif
.        comma = ","
.    endfor
AS
    SET NOCOUNT ON
.if view.have_inherit ?= 1
    DECLARE @feedback integer
.  param_type = type_sql_varchar
.  for view.inherit
.    set_field_target_type ()
.    for field
.     if !defined (size)
.         field.size = 30
.     endif
    DECLARE @$(inherit.table)_$(source) $(param_type) ($(size))
.    endfor
.  endfor

.  for view.inherit
.    field_list = ""
.    comma      = ""
.    for field
.        field_list += comma + "@" + inherit.table + "_" + source + " OUTPUT"
.        comma  = ", "
.    endfor
.    for link
.      for field
.        field_list += comma + "@" + name
.      endfor
.    endfor

    EXECUTE @feedback =  $(object.name)_inherit_from_$(inherit.table) $(field_list:)
    IF @feedback = 1
        BEGIN
.  for inherit.field as ifield
.    for view.table
.      for table.field where name = ifield.target
            SET @$(target) = @$(inherit.table)_$(source)
.      endfor
.    endfor
.  endfor
        END
.  endfor
.endif
    INSERT INTO $(table.realname) (
.    comma = " "     
.    for field where name <> recordid &  calculated ?= 0
        $(comma)$(realname:)
.        comma = ","
.    endfor
        ) VALUES (
.    comma = " "     
.    for field where name <> recordid &  calculated ?= 0
.       if count (rule, when = "insert") > 0
.           for rule where when = "insert"
.               if    name = "timestamp"
        $(comma)CAST (@$(field.name:) As $(target_type:))
.               elsif name = "timezone"
        $(comma)'+0000'
.               elsif name = "userid"
        $(comma)@$(field.name:)
.               elsif name = "set" & field.type = "textual"
        $(comma)'$(value)'
.               elsif name = "set" 
        $(comma)$(value)
.               elsif name = "recordid"
        $(comma)CAST (@$(recordid) As Numeric (9))
.               else
.                   abort "$(script): unknown rule '$(name)' for '$(field.name)'"
.               endif
.           endfor
.       else
.           if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
        $(comma)@$(field.name:)
.           else
        $(comma)CAST (@$(field.name:) As $(target_type:))
.           endif
.       endif
.        comma = ","
.    endfor
    )
.    if recordid <> ""
    IF @@ERROR = 0
        SET @$(recordid) = CAST (@@IDENTITY As $(type_sql_varchar:) (9))
.    endif
.    stored_footer (fct_name)

.#  Create strored procedure when table not ID and update data when valid = 0
.    if recordid = ""
.      if table.type = "root"
.        fct_name = "$(object.name)_create_valid"
.      else
.        fct_name = "$(object.name)_create_$(view.name)_$(table.name)_$(table.target)_valid"
.      endif
.      stored_head (fct_name, \
                  "Procedure used in object $(object.name) to create where valid = 0")
.      comma = " "     
.      timestamp_field = ""
.      for field where calculated ?= 0
.        if count (rule, when = "insert") > 0
.          for rule where when = "insert"
.            if rule.name = "userid"
    $(comma)@$(field.name:) $(type_sql_varchar:) (9)
.              elsif name = "recordid"
    $(comma)@$(field.name:) $(type_sql_varchar:) (9) OUTPUT
.                recordid      = field.name
.                real_recordid = field.realname
.              elsif name = "timestamp"
.   timestamp_field = field.name 
    $(comma)@$(field.name:) $(type_sql_varchar:) (30) OUTPUT
.              endif
.          endfor
.        else
.          param_type = type_sql_varchar
.          if !defined (size)
.            size = 30
.          endif
.          if field.type = "textual" & field.size >= dfl.longtext_limit & unicode ?= 1
.            field.size = 4000
.          endif
    $(comma)@$(field.name:) $(param_type) ($(size))
.        endif
.        comma = ","
.      endfor
AS
    SET NOCOUNT ON
    DECLARE @record_count As integer
.      have_active = ""
.      for field where name = "active"  
.        have_active = realname
.      endfor
.if view.have_inherit ?= 1
    DECLARE @feedback integer
.  param_type = type_sql_varchar
.  for view.inherit
.    set_field_target_type ()
.    for field
.     if !defined (size)
.         field.size = 30
.     endif
    DECLARE @$(inherit.table)_$(source) $(param_type) ($(size))
.    endfor
.  endfor
.endif


.        where_clause = ""
.        comma = " WHERE "
.        for field where count (index, name = "primary")
.          if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
.            where_clause += "$(comma:)$(realname:) = @$(name:)"
.          else
.            where_clause += "$(comma:)$(realname:) = CAST (@$(field.name:) As $(target_type:))"
.          endif
.          comma = " AND "
.        endfor
.      if have_active ?<> ""
.        where_clause += " AND $(have_active) = 0"
.      endif
    SET @record_count = (SELECT count (*) FROM $(table.realname:)
                             $(where_clause:))
    IF @record_count > 0
        BEGIN
.if view.have_inherit ?= 1
.  for view.inherit
.    field_list = ""
.    comma      = ""
.    for field
.        field_list += comma + "@" + inherit.table + "_" + source + " OUTPUT"
.        comma  = ", "
.    endfor
.    for link
.      for field
.        field_list += comma + "@" + name
.      endfor
.    endfor

    EXECUTE @feedback =  $(object.name)_inherit_from_$(inherit.table) $(field_list:)
    IF @feedback = 1
        BEGIN
.  for inherit.field as ifield
.    for view.table
.      for table.field where name = ifield.target
            SET @$(target) = @$(inherit.table)_$(source)
.      endfor
.    endfor
.  endfor
        END
.  endfor
.endif

        UPDATE $(table.realname) SET 
.      comma = " "
.      for field where count (index, name = "primary") = 0 &  !defined (group) & calculated ?= 0
.        if count (rule, when = "insert") 
.          for rule where when = "insert"
.            if    name = "timestamp"
            $(comma)$(realname)     = CAST (@$(field.name:) As $(target_type:))
.            elsif name = "timezone"
            $(comma)$(realname)     = '+0000'
.            elsif name = "userid"
            $(comma)$(realname)     = @$(field.name:)
.            elsif name = "set" & type = "textual"
            $(comma)$(realname)     = '$(value)'
.            elsif name = "set"
            $(comma)$(realname)     = $(value)
.            else
.              abort "$(script): unknown rule '$(name)' for '$(field.name)'"
.            endif
.          endfor
.        else
.          if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
            $(comma)$(realname)     = @$(field.name:)
.          else
            $(comma)$(realname)     = CAST (@$(field.name:) As $(target_type:))
.          endif
.        endif
.        comma = ","
.      endfor
        WHERE 
.      comma = "     "
.      for field where count (index, name = "primary")
.        if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
           $(comma)$(realname)     = @$(field.name:)
.        else
           $(comma)$(realname)     = CAST (@$(field.name:) As $(target_type:))
.        endif
.        comma = " AND "
.      endfor
        RETURN 1
        END
    ELSE
        RETURN 0
.      stored_footer (fct_name)
.    endif

.    for field where calculated ?= 0
.       for table where type = "child"
.           generate_create_sp ()
.       endfor
.    endfor
.for table.field as tmpfield where defined (add4create)
.  delete tmpfield
.endfor
.endmacro

##############################################################################
function do_stored_proc_delete
##############################################################################
   for view where name = "delete"
       for table
          generate_delete_table_sp ()
       endfor
   endfor
endfunction

##############################################################################
.macro generate_delete_table_sp
.##############################################################################
.## ADD all field needed by delete rule into the view
.  for dfl.table as dbtable where dbtable.name = table.name
.    for dbtable.field as dbfield where count (rule, when = "delete")
.      if count (table.field, name = dbfield.name) = 0
.        copy dbfield to table
.          for table.field as dfield where name = dbfield.name
.             dfield.add4delete = 1
.             dfield.calculated = 0
.             dfield.size       = dbfield.size?30
.          endfor
.      endif
.    endfor
.  endfor
.  soft_delete = 0
.  for dfl.table as dbtable where dbtable.name = table.name
.    if count (rule, name = "soft delete") 
.       soft_delete = 1
.    endif
.  endfor
.    revised_field = ""
.    if table.type = "root"
.        fct_name = "$(object.name)_delete"
.    else
.        fct_name = "$(object.name)_delete_$(table.name)"
.    endif
.    set_field_target_type ()
.    stored_head (fct_name, \
                  "Procedure used in object $(object.name) to delete record")
.    comma = " "
.    if soft_delete
.        for field where !defined (group) &  calculated ?= 0
.            if count (index, name = "primary") > 0
    $(comma)@$(field.name:) $(type_sql_varchar:) ($(size))
.                comma = ","
.            endif
.            for rule where when = "delete"
.                if name = "userid"
    $(comma)@$(field.name:) $(type_sql_varchar:) ($(size))
.                elsif name = "timestamp"
    $(comma)@$(field.name:) $(type_sql_varchar:) (30) OUTPUT
.   revised_field = field.name
.                endif
.                comma = ","
.            endfor
.        endfor
AS
    SET NOCOUNT ON
    UPDATE $(table.realname) SET 
.        comma = " "
.        for field where count (index, name = "primary") = 0 &  !defined (group) & calculated ?= 0
.            for rule where when = "delete"
.                if    name = "timestamp"
        $(comma)$(realname)   = @$(field.name:)
.                elsif name = "timezone"
        $(comma)$(realname)   = '+0000'
.                elsif name = "userid"
        $(comma)$(realname)   = CAST (@$(field.name) As $(field.target_type))
.                elsif name = "set" & type = "textual"
        $(comma)$(realname)   = '$(value)'
.                elsif name = "set"
        $(comma)$(realname)   = $(value)
.                else
.                    abort "$(script): unknown rule '$(name)' for '$(field.name)'"
.                endif
.            comma = ","
.            endfor
.        endfor
    WHERE 
.    comma = "     "
.    for field where count (index, name = "primary")
        $(comma)$(realname) = CAST (@$(field.name) As $(field.target_type))
.        comma = " AND "
.    endfor
.    else
.        for field where count (index, name = "primary") > 0 & !defined (group)
    $(comma)@$(field.name:) $(type_sql_varchar:) ($(size))
.            comma = ","
.        endfor
AS
    SET NOCOUNT ON
    DELETE FROM $(table.realname) WHERE 
.    comma = "     "
.    for field where count (index, name = "primary")
        $(comma)$(realname) = CAST (@$(field.name) As $(field.target_type))
.        comma = " AND "
.    endfor
   
.    endif
.    stored_footer (fct_name)
.    for field where calculated ?= 0
.        for table where type = "child"
.            generate_delete_table_sp ()
.        endfor
.    endfor
.    for table.field as tmpfield where defined (add4delete)
.        delete tmpfield
.    endfor
.endmacro

##############################################################################
function do_stored_proc_update
##############################################################################
   if object.have_inherit_update ?= 1
       generate_propagate_data ()
   endif
   for view where defined (update_view)
     for table
       generate_update_object_sp ()
     endfor
   endfor
endfunction
##############################################################################
.macro generate_propagate_data ()
.##############################################################################

.for root.ofl
.for object as obj
.for inherit where table = object.handler
.    fct_name = "$(object.name)_propagate_data_to_$(obj.name)"
.    set_field_target_type ()
.    stored_head (fct_name, \
                  "Procedure used in object $(object.name) to propagate data to $(obj.name)")
.    comma = "  "
.    for field
     $(comma)@old_$(source)  $(target_type)
.        comma = ", "
.    endfor
.    for link
.-        set_field_target_type ()
.        for field
     $(comma)@link_$(target_realname)  $(type_sql_varchar:) ($(size?30))
.        endfor
.    endfor
.    for field
     $(comma)@new_$(source)  $(type_sql_varchar:) ($(size?30))
.    endfor
.    for dfl.table as dtable where name = obj.name
.      for field where count (rule, when = "update")
     $(comma)@$(realname)    $(type_sql_varchar:) ($(size?30))
.      endfor
.    endfor
AS
    SET NOCOUNT ON
.---------------------------
.- Declare Working variable
.---------------------------
.    for dfl.table as dtable where name = obj.name
.        set_field_target_type ()
.        for inherit.field as ifield
.            for dtable.field as dfield where name = ifield.target
    DECLARE @$(realname)      $(target_type)     
.            endfor
.        endfor
.        for index where name = "primary"
.          set_field_target_type ()
.          for field
    DECLARE @$(field.realname) $(target_type)
.          endfor
.        endfor
.    endfor
    DECLARE @do_update           integer
    DECLARE @$(object.name)_cur  CURSOR
.-----------------------
.- Declare select cursor
.-----------------------
    SET  @$(object.name)_cur   = CURSOR LOCAL SCROLL_LOCKS FOR SELECT 
.    comma = "  "
.    for field
         $(comma)$(T_REALNAME)
.        comma = ", "
.    endfor
.    for dfl.table as dtable where name = obj.name
.        for index where name = "primary"
.            for field
         $(comma)$(FIELD.REALNAME)
.            endfor
.        endfor
.    endfor
         FROM $(table_root_realname:) WHERE
.    for link
.        comma = ""
.        for field
         $(comma)$(realname) = @link_$(target_realname)
.          comma = " AND "
.        endfor
.    endfor

.---------------------
.- Fetch first record
.---------------------
    OPEN @$(object.name)_cur
    FETCH NEXT FROM @$(object.name)_cur
    INTO 
.    comma = "  "
.    for field
         $(comma)@$(t_realname)
.        comma = ", "
.    endfor
.    for dfl.table as dtable where name = obj.name
.        for index where name = "primary"
.            for field
         $(comma)@$(field.realname)
.            endfor
.        endfor
.    endfor
    WHILE @@FETCH_STATUS = 0
      BEGIN
.--------------------
.- Copy New value
.--------------------
        SET @do_update = 0
.       for field
.           if link_type = "copy"
.               margin = "  "
.             if type = "textual"
        IF ISNULL (@old_$(source), '') = ISNULL (@$(t_realname), '')
.             else
        IF ISNULL (@old_$(source), 0) = ISNULL (@$(t_realname), 0)
.             endif
          BEGIN
.           else
.               margin = ""
.           endif
.           if t_type = "textual"
            IF ISNULL (@$(t_realname), '')  <> ISNULL (@new_$(source), '')
              BEGIN  
                SET @$(t_realname)  = @new_$(source)
                SET @do_update      = 1
              END
.           else
            IF ISNULL (@$(t_realname), 0)  <> CAST (ISNULL (@new_$(source), '0') As $(target_type:))
              BEGIN
                SET @$(t_realname)  = CAST (ISNULL (@new_$(source), '') As $(target_type:))
                SET @do_update      = 1
              END
.           endif
.           if link_type = "copy"
          END
.           endif
.       endfor

.-------------------------
.- Update the child record
.-------------------------
        IF @do_update = 1
          BEGIN
            UPDATE $(table_root_realname:) SET
.       comma = "  "
.       for field
                $(comma)$(t_realname)  = @$(t_realname)
.         comma = ", "
.       endfor
.    for dfl.table as dtable where name = obj.name
.# PH 2002-03-20
.#    I removed update of the revisedts on propagation because it causes
.#    conflicts with any objects already held in memory.  The update rule
.#    fields are added somewhere before here, I've not tried to fix that.
.#    This is not a good fix.
.#      for field where count (rule, when = "update")
.#        if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
.#                $(comma)$(realname)    = @$(realname)
.#        else
.#                $(comma)$(realname)    = CAST (@$(realname) As $(target_type:))
.#        endif
.#      endfor
.#
.    endfor
.       comma = "WHERE "
.       for dfl.table where name = obj.name
.         for field where count (index, name = "primary") > 0
              $(comma:)$(REALNAME) = @$(realname)
.             comma = " AND "
.         endfor
.       endfor
          END

.--------------------
.- Fetch next record
.--------------------
        FETCH NEXT FROM @$(object.name)_cur
            INTO 
.    comma = "  "
.    for field
                $(comma)@$(t_realname)
.        comma = ", "
.    endfor
.    for dfl.table as dtable where name = obj.name
.        for index where name = "primary"
.            for field
                $(comma)@$(field.realname)
.            endfor
.        endfor
.    endfor
      END
    CLOSE      @$(object.name)_cur
    DEALLOCATE @$(object.name)_cur
.    stored_footer (fct_name)
.endfor
.endfor
.endfor

.endmacro

##############################################################################
.macro generate_update_object_sp ()
.##############################################################################
.## ADD all fields needed by update rule into the view
.  for dfl.table as dbtable where dbtable.name = table.name
.    for dbtable.field as dbfield where count (rule, when = "update")
.      if count (table.field, name = dbfield.name) = 0
.        copy dbfield to table
.        for table.field as dfield where name = dbfield.name
.            dfield.add4update = 1
.            dfield.calculated = 0
.            dfield.size       = dbfield.size?30
.        endfor
.      endif
.    endfor
.  endfor
.    revised_field = ""
.    if table.type = "root"
.        fct_name = "$(object.name)_update_$(view.name)"
.    else
.        fct_name = "$(object.name)_update_$(view.name)_$(table.name)_$(table.target)"
.    endif
.    set_field_target_type ()
.    stored_head (fct_name, \
                  "Procedure used in object $(object.name) to update record")
.    comma = " "
.    for field  where calculated ?= 0
.        if count (rule, when = "update")
.            for rule where when = "update"
.               if    name = "userid"
    $(comma)@$(field.name:)     $(type_sql_varchar:) (9)
.               elsif name = "timestamp"
.   revised_field     = field.name
.   revised_realfield = field.realname
.   revised_type      = field.target_type
    $(comma)@$(field.name:)     $(type_sql_varchar:) (30) OUTPUT
    $(comma)@$(field.name:)_new $(type_sql_varchar:) (30) OUTPUT
.               endif
.           endfor
.       else
.           param_type = type_sql_varchar
.           if !defined (size)
.               size = 30
.           endif
.           if field.type = "textual" & field.size >= dfl.longtext_limit & unicode ?= 1
.             field.size = 4000
.           endif
    $(comma)@$(field.name:)      $(param_type) ($(size))
.       endif
.       comma = ","
.   endfor
AS
    SET NOCOUNT ON
    BEGIN
.----------------------------------
.- Declaration of working variable
.-----------------------------------
    DECLARE @feedback            integer
.    for field where calculated ?= 0
.        if target_type = "text" | target_type = "ntext"
.            if unicode ?= 1
    DECLARE @$(field.realname)   $(type_sql_varchar:) (4000)
.            else
    DECLARE @$(field.realname)   $(type_sql_varchar:) (8000)
.            endif
.        else
    DECLARE @$(field.realname)   $(field.target_type)
.        endif
.    endfor
.--------------------------------------------------
.- Declare field used in propagate and not in view
.--------------------------------------------------
. if object.have_inherit_update ?= 1
.   for root.ofl
.     for object as obj
.       for inherit where table = object.handler
.         for field as ifield where count (table.field, name = ifield.source) = 0
.           if target_type = "text" | target_type = "ntext"
.             if unicode ?= 1
    DECLARE @$(field.realname)   $(type_sql_varchar:) (4000)
.             else
    DECLARE @$(ifield.realname)  $(type_sql_varchar:) (8000)
.             endif
.           else
    DECLARE @$(ifield.realname)  $(ifield.target_type)
.           endif
.         endfor
.       endfor inherit
.     endfor object
.   endfor ofl

. endif    
.-------------------
.- Get old timestamp
.-------------------
.    if revised_field <> ""
    DECLARE @old_revised_time    $(revised_type:)
    SET @old_revised_time = CAST (@$(revised_field) As $(revised_type:))
.    endif
    SET @feedback = -1

    DECLARE @$(object.name)_cur CURSOR
    SET  @$(object.name)_cur = CURSOR LOCAL SCROLL_LOCKS FOR SELECT 
.       comma = " "
.       for field where calculated ?= 0
.       if unicode ?= 1 & field.type = "textual" & field.size >= dfl.longtext_limit
        $(comma)CAST ($(field.realname) As $(field.target_type:))
.       else
        $(comma)$(field.realname)
.       endif
.           comma = ","
.       endfor
.--------------------------------------------------
.- Add field used in propagate and not in view
.--------------------------------------------------
. if object.have_inherit_update ?= 1
.   for root.ofl
.   for object as obj
.   for inherit where table = object.handler
.        for field as ifield where count (table.field, name = ifield.source) = 0 
        $(comma)$(ifield.realname)
.        endfor
.   endfor inherit
.   endfor object
.   endfor ofl
. endif    
    FROM $(realname:)
.   delim = " WHERE "
.   for field where count (index, name = "primary") > 0
          $(delim:)$(field.realname) = @$(field.name)
.       delim = " AND    "
.   endfor

    OPEN @$(object.name)_cur
    FETCH NEXT FROM @$(object.name)_cur
    INTO 
.       comma = " "
.       for field where calculated ?= 0
        $(comma)@$(field.realname:)
.           comma = ","
.       endfor
. if object.have_inherit_update ?= 1
.   for root.ofl
.   for object as obj
.   for inherit where table = object.handler
.        for field as ifield where count (table.field, name = ifield.source) = 0 
        $(comma)@$(ifield.realname)
.        endfor
.   endfor inherit
.   endfor object
.   endfor ofl
. endif    
    IF @@FETCH_STATUS = 0
        BEGIN
.    if revised_field <> ""
        IF @old_revised_time = @$(revised_realfield)
.    endif
            BEGIN
.--------------------------------
.- Call propagate data if needed
.--------------------------------
.    if object.have_inherit_update ?= 1
.      for root.ofl
.      for object as obj
.      for inherit where table = object.handler
.        param = ""
.        comma = ""
.        for field
.          param += comma + "@$(realname)"
.          comma = ", "
.        endfor
.        for table.field as dfield where count (index, name = "primary") > 0
.          param += comma + "@$(dfield.name)"
.        endfor
.        for field
.          if count (table.field, name = source) = 0
.            param += comma + "@$(realname)"
.          else
.            param += comma + "@$(source)"
.          endif
.        endfor
.        for dfl.table as dtable where name = obj.name
.          for field where count (rule, when = "update")
.            param += comma + "@$(field.name)"
.            if count (rule, name = "timestamp") > 0
.                param += "_new"
.            endif
.          endfor
.        endfor
              EXECUTE $(object.name)_propagate_data_to_$(obj.name) $(param:)

.      endfor
.      endfor
.      endfor
.    endif
.    for field where calculated ?= 0
.        if count (rule, when = "update" & name = "timestamp")
.            for rule where when = "update" & name = "timestamp"
             SET @$(field.realname:)     = CAST (@$(field.name:)_new As $(target_type:))
.            endfor
.        else
.            if field.type = "textual" & field.size > dfl.varchar_limit & size < dfl.longtext_limit
             SET @$(field.realname:)     = @$(field.name:)
.            else
.               param_type = type_sql_varchar
.               if !defined (size)
.                   size = 30
.               endif
.               if field.type <> "textual"
             IF LEN (ISNULL (@$(field.name:), CAST (@$(field.realname:) As $(param_type) ($(size))))) > 0
                 SET @$(field.realname:) = CAST (@$(field.name:) As $(target_type:))
.               else
             SET @$(field.realname:)     = CAST (ISNULL (@$(field.name:), CAST (@$(field.realname:) As $(param_type) ($(size)))) As $(target_type:))
.               endif
.            endif            
.        endif
.    endfor
             UPDATE $(table.realname) SET 
.        comma = " "
.        for field where count (index, name = "primary") = 0 &  !defined (group) & calculated ?= 0
.            if count (rule, when = "update")
.                for rule where when = "update"
.                    if    name = "timestamp"
                $(comma)$(realname)     = @$(field.realname:)
.                    elsif name = "timezone"
                $(comma)$(realname)     = '+0000'
.                    elsif name = "userid"
                $(comma)$(realname)     = @$(field.realname:)
.                    elsif name = "set" & type = "textual"
                $(comma)$(realname)     = '$(value)'
.                    elsif name = "set"
                $(comma)$(realname)     = $(value)
.                    else
.                        abort "$(script): unknown rule '$(name)' for '$(field.name)'"
.                    endif
.                endfor
.            else
                $(comma)$(realname)     = @$(field.realname:)
.            endif
.            comma = ","
.        endfor
            WHERE 
.    comma = "     "
.    for field where count (index, name = "primary")
                $(comma)$(realname) = @$(field.name)
.        comma = " AND "
.    endfor
            IF @@ERROR = 0
                BEGIN
.                   delete_child_record ()
                    SET @feedback = 1
.               if revised_field <> ""
                    SET @$(revised_field) = @$(revised_field)_new
.               endif
                END
            END
.    if revised_field <> ""
        ELSE
            BEGIN
                SET @feedback = 0
                SET @$(revised_field) = CAST (@$(revised_realfield) As $(type_sql_varchar:) (30))
            END
.    endif
        END
    END
    CLOSE      @$(object.name)_cur
    DEALLOCATE @$(object.name)_cur
    RETURN @feedback
.    stored_footer (fct_name)
.    for field where calculated ?= 0
.        for table where type = "child"
.-            generate_update_object_sp ()
.            if view.name <> "create"
.                generate_create_sp ()
.            endif
.        endfor
.    endfor
.for table.field as tmpfield where defined (add4update)
.  delete tmpfield
.endfor
.endmacro

##############################################################################
.macro do_stored_proc_query
.##############################################################################
.   for query
.## ADD all fields needed by query into the view
.     for object.view where name = query.view
.       for table
.         for dfl.table as dbtable where dbtable.name = table.name
.           for dbtable.field as dbfield where count (rule, when = "update" & name = "timestamp")
.             if count (table.field, name = dbfield.name) = 0
.               copy dbfield to table
.               for table.field as dfield where name = dbfield.name
.                 dfield.add4query  = 1
.                 dfield.calculated = 0
.                 dfield.size       = dbfield.size?30
.               endfor
.             endif
.           endfor
.         endfor
.         make_table_select ()
.       endfor
.     endfor
.        fct_name = "$(object.name)_query_$(query.name)"
.        set_field_target_type ()
.        stored_head (fct_name, \
                    "Procedure used in object $(object.name) to query record")
     @position_mode   $(type_sql_varchar:) (10)
.    for object.view where name = query.view
.      for table
.        for dfl.table as dfltable where dfltable.name = table.name
.          for index where name = "$(query.index?"primary")"
.            nb_field_index = count (index.field)
.            if nb_field_index > 1
    ,@match_nb_field  integer
.            endif
.            for field
.              param_type = type_sql_varchar
.                if !defined (size)
.                    size = 30
.                endif
.                if !defined (field.type)
.                    echo 'No field type for $(field.name?"?") in $(table.name)'
.                endif
.                if field.type = "textual" & field.size >= dfl.longtext_limit & unicode ?= 1
.                    field.size = 4000
.                endif
    ,@$(field.name:)  $(param_type) ($(size))
.            endfor
.          endfor
.        endfor
.    endfor
.   arg_index = 1
.   while defined (arg$(arg_index))
    ,@$(arg$(arg_index)) $(type_sql_varchar:) ($(arg$(arg_index)_size?30))
.       arg_index += 1
.   endwhile
.   if defined (query.filter)
    ,@filter $(type_sql_varchar:) (255)
.   endif
.  endfor
AS
    SET NOCOUNT ON
.   for object.view where name = query.view
.     for table
.       set_field_target_type ()
.################################################################################
.# stored procedure use if statement for position mode, order of make query cursor
.# is important for performance: call most used position mode first
.################################################################################
.       make_query_cursor ("first")
.       make_query_cursor ("gt")
.       make_query_cursor ("lt")
.       make_query_cursor ("ge")
.       make_query_cursor ("le")
.       make_query_cursor ("last")
.       make_query_cursor ("eq")
.       stored_footer (fct_name)
.#######################################
.#       Resolve child and lookup link #
.#######################################
.       for field where calculated ?= 0
.         for table
.           fct_name = "$(object.name)_query_$(view.name)_$(field.realname)_$(table.name)"
.           if !defined ($(fct_name))
.           stored_head (fct_name, \
                          "Procedure used in object $(object.name) to fetch lookup or child $(field.realname) in view $(view.name)")
.           param_type = type_sql_varchar
.           if !defined (size)
.             size = 30
.           endif
.           if field.type = "textual" & field.size > dfl.longtext_limit & unicode ?= 1
.              field.size = 4000
.           endif
    @$(field.name:) $(param_type) ($(size))
AS
    SET NOCOUNT ON
.   make_table_select ()
    SELECT $(select) FROM $(realname) WHERE
.           if field.type = "textual" & field.size > dfl.varchar_limit & field.size < dfl.longtext_limit
        $(target) = @$(field.name)
.           else
        $(target) = CAST (@$(field.name:) As $(target_type:))
.           endif
.           for ofl.object as objobject where name = table.name
.             if soft_delete = 1
.               for rule where name = "soft delete"
.                 for dfl.table as dfltable where name = objobject.name
.                   for field where name = rule.what
        AND $(field.realname) = 1
.                   endfor
.                 endfor
.               endfor
.             endif
.           endfor
.           stored_footer (fct_name)
.           $(fct_name) = 1
.           endif
.         endfor
.       endfor
.       for table.field as tmpfield where defined (add4query)
.           delete tmpfield
.       endfor
.     endfor
.   endfor
.  endfor
.endmacro

##############################################################################
function make_query_cursor (position_mode)
##############################################################################
   if position_mode = "gt"
     operator     = ">"
     inv_operator = "<"
     invert_order = "false"
   elsif position_mode = "lt"
     operator     = "<"
     inv_operator = ">"
     invert_order = "true"
   elsif position_mode = "ge"
     operator     = ">="
     inv_operator = "<="
     invert_order = "false"
   elsif position_mode = "le"
     operator     = "<="
     inv_operator = ">="
     invert_order = "true"
   elsif position_mode = "eq"
     operator     = "="
     inv_operator = "="
     invert_order = "false"
   elsif position_mode = "first"
     operator     = ">="
     inv_operator = "<="
     invert_order = "false"
   elsif position_mode = "last"
     operator     = "<="
     inv_operator = ">="
     invert_order = "true"
   else
     abort ("Invalid position mode $(position_mode)")
   endif
   field_counter = 0
>    IF @position_mode = '$(position_mode)'
>      BEGIN
   if operator = inv_operator
>        SELECT $(table.select) FROM $(table.realname) WHERE (
     for dfl.table as dfltable where dfltable.name = table.name
       for index where name = "$(query.index?"primary")"
         delim = "     "
         for field 
           get_query_stored_value ("match", "")
>              $(delim:)$(realname:)  =  $(value:)
           delim = " AND "
         endfor
         end_query ()
       endfor
     endfor
   else
       while (field_counter < nb_field_index)
           if nb_field_index > 1
>        IF @match_nb_field = $(field_counter)
>            BEGIN
           endif
         if nb_field_index > 1
>            SELECT $(table.select) FROM $(table.realname)
         else
>        SELECT $(table.select) FROM $(table.realname)
         endif
         if field_counter = 0
           delim = " WHERE (( "
         else
           delim = " WHERE ( "
         endif
         for dfl.table as dfltable where dfltable.name = table.name
           for index where name = "$(query.index?"primary")"
             for field 
               if index (field) <= field_counter
                 get_query_stored_value ("match", "")
>                  $(delim:)$(realname:)  =  $(value:)
                 delim = " AND "
               endif
             endfor
             if (field_counter > 0)
               inter_group = "AND (("
             else
               inter_group = " WHERE (("
             endif
             inter_field = "      "
             for field 
               if index () > field_counter & position_mode <> "first" & position_mode <> "last"
                 last_index = index ()
                 for index.field as pfield 
                   if index () > field_counter & index () <= last_index
                     get_query_stored_value (position_mode, pfield.order?"asc")
                     if index () < last_index
>                  $(inter_group:)$(inter_field:)$(realname:)  =         $(value:)
                     else
                       if pfield.order ?= "desc"
                         sign = inv_operator
                       else
                         sign = operator
                       endif
>                  $(inter_group:)$(inter_field:)$(realname:)  $(sign:)  $(value:)
                     endif
                     inter_group = "      "
                     inter_field = "  AND "
                   endif
                 endfor
                 inter_group = ") OR ("
                 inter_field = "      "
               endif
             endfor
             if position_mode <> "first" & position_mode <> "last"
               if field_counter > 0 
>                  ))
               else
>                  )
               endif
             endif
           endfor
         endfor
         end_query ()    
         field_counter += 1
         if nb_field_index > 1
>            RETURN 0
>          END
         endif
       endwhile
   endif
>        RETURN 0
>      END
endfunction

function end_query
     have_active = 0
     for dfl.table as dbtable where dbtable.name = table.name
       for rule where name = "soft delete"
         for dbtable.field as dbfield where name = rule.what
          if (position_mode <> "first" & position_mode <> "last") | field_counter > 0
              delim = " ) AND"
          else
              delim = "WHERE "
          endif
          have_active = 1
           if nb_field_index > 1
>             $(delim:)  $(dbfield.realname) <> $(rule.value)
           else
>           $(delim:)   $(dbfield.realname) <> $(rule.value)
           endif
         endfor
       endfor
     endfor
    if have_active = 0 & (field_counter > 0 | (position_mode <> "first" & position_mode <> "last"))
>               )
    endif              
    if defined (query.condition) 
        if !defined (query.parsed_condition)
            #  loop for arg1..n
            arg_index = 1
            while defined (query.arg$(arg_index))  
                arg$(arg_index) = "@$(arg$(arg_index))"
                arg_index += 1
            endwhile
            gsl 'query.parsed_condition = \"$(condition:)\"'
        endif
          if (position_mode <> "first" & position_mode <> "last") | field_counter > 0 | have_active = 1
              delim = " AND "
          else
              delim = " WHERE "
          endif
>                  $(delim:) ($(query.parsed_condition:))
    endif
    if defined (query.filter)
        if (position_mode <> "first" & position_mode <> "last") | field_counter > 0 | have_active = 1 | defined (query.condition)
            delim = " AND "
        else
            delim = " WHERE "
        endif
>                  $(delim:) (@filter = '' OR $(query.real_filter:?) like @filter)
    endif

     delim = " ORDER BY "
     for dfl.table as dfltable where dfltable.name = table.name
       for dfltable.index where name = "$(query.index?"primary")"
         if field_counter > 0
           for field 
             if index () = count (index.field)
               if invert_order = "true"
                 if order ?= "desc"
                   match_order = "ASC"
                 else
                   match_order = "DESC"
                 endif
               else
                   match_order = field.order?"ASC"
               endif
             endif
           endfor 
         endif
         for index.field 
           if index () <= field_counter
              field_order = match_order
           else
             if invert_order = "true"
               if order ?= "desc"
                 field_order = "ASC"
               else
                 field_order = "DESC"
               endif
             else
               field_order = field.order?"ASC"
             endif
           endif
           if nb_field_index > 1
>              $(delim:)$(realname:)  $(FIELD_ORDER)
           else
>          $(delim:)$(realname:)  $(FIELD_ORDER)
>          OPTION (FAST 20)
           endif
           delim = "         , "
         endfor field
       endfor index
     endfor dfl.table
endfunction
##############################################################################
function get_query_stored_value (position_mode, field_order)
##############################################################################
  query_type = position_mode
  if field_order = "desc"
    if    query_type  = "last"
        query_type    = "first"
    elsif query_type  = "first"
        query_type    = "last"
    endif
  endif
  if type = "textual"
    if query_type = "last"
      value = "'" + ("z" * size?1) + "'"
    elsif query_type = "first"
      value = "' '"
    else
      value = " @$(name:)"
    endif
  elsif type = "timestamp"
    if query_type = "last"
      value = "99999999"
    elsif query_type = "first"
      value = "0"
    else
      value = " @$(name:)"
    endif
  else
    if query_type = "last"
      if size < 28
          value = "9" * size?1 
      else
          value = "9" * 27 
      endif
    elsif query_type = "first"
      value = "0"
    else
      value = " @$(name:)"
    endif
  endif
endfunction

##############################################################################
.macro do_stored_proc_subselect
.##############################################################################
.for subselect

.    fct_name = "$(object.name)_subselect_$(subselect.name)"
.    stored_head (fct_name, \
                 "Procedure used in object $(object.name) to execute subselect $(name)")
.    delim = ""
.    using_index = 1
.    while defined (using$(using_index))
.        if using$(using_index)_type = "textual"
    $(delim)@$(using$(using_index)) $(type_sql_varchar:) ($(using$(using_index)_size))
.        elsif using$(using_index)_type = "timestamp"
    $(delim)@$(using$(using_index)) DECIMAL (18, 7)
.        else
    $(delim)@$(using$(using_index)) INTEGER
.        endif
.        using_index += 1
.        delim = ","
.    endwhile
.    arg_index = 1
.    while defined (arg$(arg_index))
.        if arg$(arg_index)_type = "textual"
    $(delim)@$(arg$(arg_index)) $(type_sql_varchar:) ($(arg$(arg_index)_size))
.        elsif arg$(arg_index)_type = "timestamp"
    $(delim)@$(arg$(arg_index)) DECIMAL (18, 7)
.        else
    $(delim)@$(arg$(arg_index)) INTEGER
.         endif
.         arg_index += 1
.         delim = ","
.     endwhile
.     for subselect.field as sfield
.         if sfield.type = "textual"
    $(delim)@$(sfield.name) $(type_sql_varchar:) ($(sfield.size)) OUTPUT
.         elsif sfield.type = "timestamp"
    $(delim)@$(sfield.name) DECIMAL (18, 7) OUTPUT
.         else
    $(delim)@$(sfield.name) INTEGER OUTPUT
.         endif
.         delim = ","
.     endfor
AS
    SET NOCOUNT ON
.     for subselect.field as sfield
.         if sfield.type = "textual"
    SET @$(sfield.name) = ''
.         else
    SET @$(sfield.name) = 0
.         endif
.     endfor
.template 0
      if !defined (subselect.parsed_sql)
          #  loop for arg1..n
          using_index = 1
          while defined (using$(using_index))
              using$(using_index) = "@$(using$(using_index))"
              using_index += 1
          endwhile
          
          # Set Fetch value in select
          fields = ""
          delim = ""
          for subselect.field as sfield
             fields += delim + "@$(sfield.name)" + " = " + sfield.source
             delim = ", "
          endfor
          arg_index = 1
          while defined (arg$(arg_index))
              arg$(arg_index) = "@$(arg$(arg_index))"
              arg_index += 1
          endwhile

          gsl 'subselect.parsed_sql = \"$(subselect.value:)\"'
      endif
>    $(subselect.parsed_sql:)

endtemplate
.    stored_footer (fct_name)
.endfor
.endmacro
