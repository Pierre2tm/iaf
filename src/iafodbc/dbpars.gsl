- 12/22/2000 3:57PM
-
- IMPORTANT NOTE : This script has been copied and patched from the  script
- I was writing to generate parsers. The original script was not finished,
- but we needed a quick patch for iafodbc to handle item one by one (instead
- of loading everything in memory before handling).
- Thus, this script should be removed from here one day, and should be
- cleaned up !!!
-
- gslgen dbpars[.gsl]
-    ---> generates dbpars.c which is included in iafodbc.c and iafmysql!!!
-

----------------------------------------------------------------------------
---------------------------- MACRO AND FUNCTIONS ---------------------------
----------------------------------------------------------------------------


.macro header
/*  ----------------------------------------------------------------<Prolog>-
    Name:       dbpars.c
    Title:      XML serialisation functions
    Package:    Standard Function Library (SFL)

    Written:    1996/06/08  iMatix SFL project team <sfl@imatix.com>
    Revised:    $(date)

    Synopsis:   Loads XML file into memory, to/from disk files.

    Copyright:  Copyright (c) 1991-2000 iMatix Corporation
    License:    This is free software; you can redistribute it and/or modify
                it under the terms of the SFL License Agreement as provided
                in the file LICENSE.TXT.  This software is distributed in
                the hope that it will be useful, but without any warranty.
 ------------------------------------------------------------------</Prolog>-*/


.endmacro


.macro define_global_var

struct
{
    char
        file_name [256];
    char
        *table_name;
    LIST
        col_list;
    long
        recno;
    Bool
        db_error;
    Bool
        encoded_data;
} db_globals;


.endmacro


.macro define_item_management

Bool table_management (XML_ITEM *parent, XML_ITEM *child)
{
    Bool res = TRUE;

    /* parent is not used */
    ASSERT (child);

    db_globals.table_name = update_table_struct (child, &db_globals.col_list);
    if (db_globals.table_name == NULL)
      {
        res = FALSE;
        db_globals.db_error = TRUE;
        get_db_error_message ();
        fprintf (out_file, "<error ROW=\\"%ld\\" CREATE_TABLE=\\"TRUE\\" MESSAGE=\\"%s\\" />\\n",
                    db_globals.recno, message);
      }
#ifdef DB_ODBC
    if (have_identity)
      {
        SQLFreeStmt (h_statement, SQL_UNBIND);
        SQLFreeStmt (h_statement, SQL_CLOSE);
        sprintf (db_globals.file_name, "SET IDENTITY_INSERT %s ON", db_globals.table_name);
        return_code = SQLExecDirect (h_statement, db_globals.file_name, SQL_NTS);
        if (return_code != SQL_SUCCESS
        &&  return_code != SQL_SUCCESS_WITH_INFO)
          {
            get_db_error_message ();
            db_globals.db_error = TRUE;
            res = FALSE;
          }
      }
    SQLFreeStmt (h_statement, SQL_UNBIND);
    SQLFreeStmt (h_statement, SQL_CLOSE);
#endif

    xml_free (child);

    return res;
}


Bool record_management (XML_ITEM *parent, XML_ITEM *child)
{
    Bool res = TRUE;

    /* parent is not used */
    ASSERT (child);

    if (import_row (db_globals.table_name, child, &db_globals.col_list, db_globals.encoded_data))
        db_globals.recno++;
    else
      {
        get_db_error_message ();
        fprintf (out_file, "<error row=\\"%ld\\" message=\\"%s\\" />\\n",
                    db_globals.recno + 1, message);
        res = FALSE;
        db_globals.db_error = TRUE;
      }

    xml_free (child);

    return res;
}

.endmacro




----------------------------------------------------------------------------
.macro define_include
#include "prelude.h"                    /*  Universal include file           */
#include "sfldate.h"
#include "sflfile.h"
#include "sflmem.h"
#include "sflsymb.h"
#include "sflhttp.h"
#include "sflstr.h"
#include "sflxml.h"
#include "dbpars.h"


.endmacro


----------------------------------------------------------------------------
.macro define_mode_constants
/* these constants must be used as 'mode' parameter in parse_XXX functions */
#define MODE_ONCE                (1)
#define MODE_ONCE_OR_MORE        (2)
#define MODE_ZERO_OR_MORE        (3)
#define MODE_OPTIONAL            (4)


.endmacro



----------------------------------------------------------------------------
.macro define_error_messages

#define NO_ERROR_MSG                      (-1)
#define CANNOT_FIND_FILE                    0
#define CANNOT_OPEN_FILE                    1
#define ERROR_CLOSING_FILE                  2
#define EXPECTED_EOF                        3
#define UNEXPECTED_EOF                      4
#define UNEXPECTED_CHAR                     5
#define EXPECTED_STRING                     6
#define OUT_OF_MEMORY                       7

const char * error_messages[] =
  {
    /* static messages */
/*  0 */       "Could not find XML file."
/*  1 */     , "Could not open XML file."
/*  2 */     , "Error closing file."
/*  3 */     , "End of file expected."
/*  4 */     , "Unexpected end of file."
/*  5 */     , "Unexpected character."
/*  6 */     , "Expected string."
/*  7 */     , "Out of memory"
    /* messages from xml spec decription */
.   root.next_error_code = 8       /* IMPORTANT : if messages are added
.                                   * above, you must increase this var */
.   for item
.       if defined (attach_error_msg)
.           .attach_error_code = root.next_error_code
.           root.next_error_code += 1
/* $(.attach_error_code) */ , "$(attach_error_msg:)"
.       endif
.       define_handler_error_messages ()
.   endfor
  };

.endmacro


----->    SUB MACROS FOR 'define_error_messages' MACRO
.macro define_handler_error_messages
.   for component
.       if defined (handler_error_msg)
.           .handler_error_code = root.next_error_code
.           root.next_error_code += 1
/* $(.handler_error_code) */ , "$(handler_error_msg:)"
.       endif
.       define_handler_error_messages ()
.   endfor
.endmacro


----------------------------------------------------------------------------
.macro define_xml_buffer
/* it is necessary to have an even XML_BUFFER_SIZE and to have
 * HALF_BUFFER defined as the exact half of XML_BUFFER_SIZE
 * I didn't want to use (XML_BUFFER_SIZE / 2) to avoid expensive divisions
 * However, perhaps compilers solve this
 */

#define XML_BUFFER_SIZE          (0x100000)  /* 1 Mb */
#define HALF_XML_BUFFER_SIZE     (0x80000)   /* 500 Kb */
#define TAB_EXPANSION        8
#define STACK_DEPTH          500
#define ERROR_MSG_SIZE       512


typedef struct _XML_CONTEXT
{
    long
            pos;                    /* pos relatively to start of the file.*/
    int
            line;

} XML_CONTEXT;


typedef struct _XML_BUFFER
{
    char
        *cache,
        *cache_last_ptr,
        *cache_cur_ptr;
    int
        stack_top,
        stack_depth,
        cache_size;
    long
        cache_offset;              /* tells which byte (relatively to start of file)
                                      is loaded in cache[0] */
    XML_CONTEXT
        error_ctxt,
        *stack;
    long
        file_size;
    char
        *error_msg;
    int
        error_code;
    const char
        *filename;
    FILE
        *fd;
} XML_BUFFER;

#define cur_ctxt(BUF)        ((BUF)->stack [(BUF)-> stack_top])


#define get_next_char(BUF, RES)                                            \\
    ASSERT (BUF);                                                          \\
    if ( !BUF-> cache_cur_ptr                                              \\
            || (BUF-> cache_cur_ptr == BUF-> cache_last_ptr) )             \\
        handle_page_fault (BUF);                                           \\
    /* if cache_cur_ptr is valid, it must be pointing to the cache, or */  \\
    /* to the char after last one (INVARIANT) */                           \\
    ASSERT (BUF-> cache_cur_ptr                                            \\
        ? (BUF-> cache_cur_ptr >= BUF-> cache)                             \\
              && (BUF-> cache_cur_ptr < BUF-> cache_last_ptr)              \\
        : TRUE);                                                           \\
                                                                           \\
    if (BUF-> cache_cur_ptr)                                               \\
      {                                                                    \\
        cur_ctxt(BUF).pos++;                                               \\
        if (*BUF-> cache_cur_ptr == '\\r')                                 \\
            cur_ctxt(BUF).line++;                                          \\
        RES = *BUF-> cache_cur_ptr++;                                      \\
      }                                                                    \\
    else                                                                   \\
        RES = 0;



#define clear_error(BUF)                                                   \\
  {                                                                        \\
    BUF-> error_code = NO_ERROR;                                           \\
    BUF-> error_ctxt.pos = -1;                                             \\
  }

#define set_error(BUF, ERROR_CODE)                                         \\
  {                                                                        \\
    if (cur_ctxt(BUF).pos >= BUF-> error_ctxt.pos)                         \\
      {                                                                    \\
        memcpy (&BUF-> error_ctxt,&cur_ctxt(BUF), sizeof(XML_CONTEXT));    \\
        BUF-> error_code = ERROR_CODE;                                     \\
      }                                                                    \\
  }


.endmacro


----------------------------------------------------------------------------
.macro define_try_mechanism
/***************************************************************************/
/* these macros are used to TRY parsing something.                         */
/* the TRY encapsulation allows a roll back while parsing.                 */
/* meaning that buffer context is saved before parsing function            */
/* is called. If the parse function succeed, saved context is dropped      */
/* otherwise, saved context is restored                                    */
/*                                                                         */
/* to use TRY mechanism within a function :                                */
/* - as first statement of the function : ENABLE_TRY(buf)                  */
/*   where buf is an XML_BUFFER (not NULL)                                 */
/*                                                                         */
/* Bool f (XML_BUFFER *buf, blah blah)                                     */
/* {                                                                       */
/*    ENABLE_TRY                                                           */
/*    ...                                                                  */
/*                                                                         */
/*    TRY (parse_XXX);                                                     */
/*    if (TRY_SUCCEED)                                                     */
/*       ...                                                               */
/*    // or                                                                */
/*    if (TRY_FAILED)                                                      */
/*       ...                                                               */
/* }                                                                       */
/*                                                                         */
/* TRY_HANDLER is quite the same, except a handler is applied if parsing   */
/* function succeed                                                        */
/***************************************************************************/
#define ENABLE_TRY                                                        \\
    Bool                                                                  \\
            try_res;


void save_context (XML_BUFFER *buf)
{
    ASSERT (buf);

    ASSERT (buf-> stack_top >= 0);
    ASSERT (buf-> stack_top < buf-> stack_depth);
    if (buf-> stack_top == buf-> stack_depth - 1)
      {
        /* our static stack is full. We realloc */
        buf-> stack_depth += STACK_DEPTH;
        buf-> stack = (XML_CONTEXT *)
                            mem_realloc (buf-> stack, buf-> stack_depth);
        if (!buf-> stack)
          {
            set_error (buf, OUT_OF_MEMORY);
            return;
          }
      }

    ASSERT (sizeof (XML_CONTEXT) == 8);
    memcpy (&buf-> stack [buf-> stack_top + 1],
            &cur_ctxt(buf),
//             8 );
            sizeof(XML_CONTEXT));
    buf-> stack_top++;
}


void restore_context (XML_BUFFER *buf)
{
    ASSERT (buf);
    buf-> stack_top--;

    /* we must update or invalidate cache information */
    if (buf-> cache_cur_ptr)
      {
        /* cache still has revelant information */
        ASSERT (cur_ctxt(buf).pos >= 0);
        ASSERT (cur_ctxt(buf).pos < buf-> file_size);
        ASSERT (cur_ctxt(buf).pos
                      < buf-> cache_offset + buf-> cache_size);
        if ( cur_ctxt(buf).pos >= buf-> cache_offset)
            /* cur pos is still in the cache */
            buf-> cache_cur_ptr =
                    &buf-> cache [cur_ctxt(buf).pos - buf-> cache_offset];
        else
            buf-> cache_cur_ptr = NULL;
      }
}


void drop_context (XML_BUFFER *buf)
{
    ASSERT (buf);
    ASSERT (buf-> stack_top > 0);
    buf-> stack_top--;
    memcpy (&cur_ctxt(buf),
            &buf-> stack[buf-> stack_top + 1],
            sizeof (XML_CONTEXT));
}



#define _save_context                                                          \\
{                                                                             \\
    ASSERT (buf);                                                             \\
                                                                              \\
    ASSERT (buf-> stack_top >= 0);                                            \\
    ASSERT (buf-> stack_top < buf-> stack_depth);                             \\
    if (buf-> stack_top == buf-> stack_depth - 1)                             \\
      {                                                                       \\
        /* our static stack is full. We realloc */                            \\
        buf-> stack_depth += STACK_DEPTH;                                     \\
        buf-> stack = (XML_CONTEXT *)                                         \\
                            mem_realloc (buf-> stack, buf-> stack_depth);     \\
        if (!buf-> stack)                                                     \\
            ASSERT (FALSE);   /* XXX TODO : exhausted memory management */    \\
      }                                                                       \\
                                                                              \\
    memcpy (&buf-> stack [buf-> stack_top + 1],                               \\
            &cur_ctxt(buf)                ,                                   \\
            sizeof(XML_CONTEXT));                                             \\
    buf-> stack_top++;                                                        \\
}


#define _restore_context                                                       \\
{                                                                             \\
    ASSERT (buf);                                                             \\
    buf-> stack_top--;                                                        \\
                                                                              \\
    /* we must update or invalidate cache information */                      \\
    if (buf-> cache_cur_ptr)                                                  \\
      {                                                                       \\
        /* cache still has revelant information */                            \\
        ASSERT (cur_ctxt(buf).pos >= 0);                                      \\
        ASSERT (cur_ctxt(buf).pos < buf-> file_size);                         \\
        ASSERT (cur_ctxt(buf).pos                                             \\
                      < buf-> cache_offset + buf-> cache_size);               \\
        if ( cur_ctxt(buf).pos >= buf-> cache_offset)                         \\
            /* cur pos is still in the cache */                               \\
            buf-> cache_cur_ptr =                                             \\
                    &buf-> cache [cur_ctxt(buf).pos - buf-> cache_offset];    \\
        else                                                                  \\
            buf-> cache_cur_ptr = NULL;                                       \\
      }                                                                       \\
}


#define _drop_context                                                          \\
{                                                                             \\
    ASSERT (buf);                                                             \\
    ASSERT (buf-> stack_top > 0);                                             \\
    buf-> stack_top--;                                                        \\
    memcpy (&cur_ctxt(buf),                                                   \\
            &buf-> stack[buf-> stack_top + 1],                                \\
            sizeof (XML_CONTEXT));                                            \\
}



/***************************************************************************/
/* - PARSE_FCT must be a complete function call (with arguments).          */
/*   That function must return a boolean (TRUE on success)                 */
/* - HANDLER must be the name of a void function, excpecting 2 arguments:  */
/*   a pointer to a struct to fill and a string                            */
/* - STRUCT_TO_FILL is the actual struct var we'll give the handler on     */
/*   success                                                               */
/* - DECODE is a boolean informing whether the string to handle (on        */
/*   success) must be decoded for HTTP meta characters                     */
/***************************************************************************/

#define TRY_HANDLER(PARSE_FCT, HANDLER, STRUCT_TO_FILL, DECODE, ERROR_CODE) \\
    save_context (buf);                                                   \\
    try_res = PARSE_FCT;                                                  \\
    if (try_res)                                                          \\
      {                                                                   \\
        try_res = HANDLER (STRUCT_TO_FILL, get_string(buf, DECODE));      \\
        if (!try_res)                                                     \\
            set_error (buf, ERROR_CODE)                                   \\
      }                                                                   \\
    if (try_res)                                                          \\
      {                                                                   \\
        if (cur_ctxt(buf).pos > buf-> error_ctxt.pos)                     \\
            clear_error (buf);                                            \\
        drop_context (buf);                                               \\
      }                                                                   \\
    else                                                                  \\
        restore_context (buf);


#define TRY(PARSE_FCT)                                                    \\
    save_context (buf);                                                   \\
    try_res = PARSE_FCT;                                                  \\
    if (try_res)                                                          \\
      {                                                                   \\
        drop_context (buf);                                               \\
        if (cur_ctxt(buf).pos > buf-> error_ctxt.pos)                     \\
            clear_error (buf);                                            \\
      }                                                                   \\
    else                                                                  \\
        restore_context (buf);


#define TRY_IS(CMAP_ENTRY)                                                \\
    save_context (buf);                                                   \\
    get_next_char (buf, try_ch);                                          \\
    try_res = is_##CMAP_ENTRY (try_ch);                                   \\
    if (try_res)                                                          \\
      {                                                                   \\
        drop_context (buf);                                               \\
        if (cur_ctxt(buf).pos > buf-> error_ctxt.pos)                     \\
            clear_error (buf);                                            \\
      }                                                                   \\
    else                                                                  \\
      {                                                                   \\
        set_error (buf, UNEXPECTED_CHAR);                                 \\
        restore_context (buf);                                            \\
      }


#define TRY_SUCCEED     (try_res)

#define TRY_FAILED      (!try_res)


.endmacro



.macro define_cmap
/*  Character classification tables and macros                               */

static byte
// static word
    cmap [256];                         /*  Character classification tables  */


/* TODO : we could define set with other sets (recursively)
and define masks.
Ex : name_char = letter ou digit

#define CMAP_NAME_CHAR         CMAP_LETTER + CMAP_DIGIT

Main advantage is that a set can be described by subsets,
and a subset can be used to describe several sets.
---> with only ONE test, we can figure out whether in set !!!
*/

.   root.nr = 1
.   for set
#define CMAP_$(NAME)        ($(root.nr))
.       root.nr *= 2
.   endfor
.   if root.nr > 256
.       abort "too much CMAP entry. change cmap declaration to 'word' instead of 'byte'"
.   endif

/*  Macros for character mapping:    */
.   for set
#define is_$(name)(ch)       (cmap [(byte) (ch)] & CMAP_$(NAME))
.   endfor

.endmacro



----------------------------------------------------------------------------
.macro function_declarations
/***************************************************************************/
/*                          FUNCTION DECLARATIONS                          */
/***************************************************************************/

/* CMAP functions                                                          */
.- Now in .h !!!    declare_cmap_functions ()

.   root.group_count = 0
/* parse functions                                                        */
.   declare_parse_item_functions ()

/* parse_group functions                                                  */
.   for item
.       declare_parse_group_functions ()
.   endfor

/* general parse functions                                                */
.   declare_general_parse_functions ()

/* XML_BUFFER manipulation function                                       */
.   declare_xml_buffer_functions ()


.endmacro


----->    SUB MACROS FOR 'function_declarations' MACRO
.macro declare_cmap_functions
void init_charmaps (void);
.endmacro


----->    SUB MACROS FOR 'function_declarations' MACRO
.macro declare_parse_item_functions
.   for item
.       if defined (parent_struct)
Bool    parse_$(name) (XML_BUFFER *buf, int mode, $(parent_struct:) *parent_struct);
.       else
Bool    parse_$(name) (XML_BUFFER *buf, int mode);
.       endif
.   endfor
.endmacro


----->    SUB MACROS FOR 'function_declarations' MACRO
.macro declare_parse_group_functions
.   for component where (type = "union" | type = "disjunct")
.       root.group_count += 1
.       component.nr = root.group_count
.           if  defined (child_struct) & !defined (handler)
Bool    parse_group_$(nr) (XML_BUFFER *buf, int mode, $(child_struct:) *parent_struct);
.           elsif  defined (parent_struct) & !defined (handler)
Bool    parse_group_$(nr) (XML_BUFFER *buf, int mode, $(parent_struct:) *parent_struct);
.           else
Bool    parse_group_$(nr) (XML_BUFFER *buf, int mode);
.           endif
.       declare_parse_group_functions ()
.   endfor
.endmacro


----->    SUB MACROS FOR 'function_declarations' MACRO
.macro declare_general_parse_functions
//#define parse_one_char(BUF, CH)    (CH == get_next_char(BUF))
Bool    parse_one_char          (XML_BUFFER *buf, const char ch);
Bool    parse_constant_string   (XML_BUFFER *buf, const char *str);
Bool    parse_any_before_char   (XML_BUFFER *buf, const char ch, Bool empty_allowed);
Bool    parse_any_before_string (XML_BUFFER *buf, const char *str);
.endmacro

.macro declare_xml_buffer_functions
XML_BUFFER    *buf_init_from_file   (const char *fullpath, char *error_msg);
XML_BUFFER    *buf_init_from_string (const char *xmlstring);
char          *get_string           (XML_BUFFER *buf, Bool decode_http);
void           buf_dispose          (XML_BUFFER **buf);
void           handle_page_fault    (XML_BUFFER *buf);
char          *build_error_message  (XML_BUFFER *buf);



.endmacro



----------------------------------------------------------------------------
.macro function_definitions
/***************************************************************************/
/*                          FUNCTION DEFINITIONS                           */
/***************************************************************************/

.   define_cmap_functions ()
.   define_main_parse_function ()
.   define_parse_item_functions ()
.   for item
.       define_parse_group_functions ()
.   endfor
.   define_general_parse_functions ()
.   define_xml_buffer_functions ()
.endmacro


----->    SUB MACROS FOR 'function_definitions' MACRO
.macro define_cmap_functions
/*  -------------------------------------------------------------------------
 *  build_charmap
 *
 *  Encode character string and flag into character map table.  Flag should
 *  be a 1-bit value from 1 to 128 (character map is 8 bits wide).
 */

static void
build_charmap (byte flag, char *string)
{
    for (; *string; string++)
        cmap [(byte) *string] |= flag;
}

static void
build_charmap_for_range (byte flag, byte min, byte max)
{
    int
            ch, intmin, intmax;

    ASSERT (min <= max);

    /* cast to cover case : min == 0 && max == 255 */
    intmin = min;
    intmax = max;

    for (ch = min; ch <= max; ch++)
      {
        ASSERT (ch <= 255);
        cmap [(byte) ch] |= flag;
      }
}

static void
build_charmap_for_except (byte flag, char *string)
{
    for (; *string; string++)
        cmap [(byte) *string] &= ~flag;
}


void
init_charmaps (void)
{
    memset (cmap, 0, sizeof (cmap));    /*  Clear all bitmaps                */
.   for set

.       for string
    build_charmap (CMAP_$(set.NAME), "$(value:)");
.       endfor
.       for range
.           any ?= 0
.           if any = 1
    build_charmap_for_range (CMAP_$(set.NAME), 0, 0xFF);
.           else
.               if !defined (min)
.                   abort "'min' is not defined in set '$(set.name)'"
.               endif
.               if !defined (max)
.                   abort "'max' is not defined in set '$(set.name)'"
.               endif
.               .mode ?= "lit"
.               if mode = "lit"
    build_charmap_for_range (CMAP_$(set.NAME), '$(min:)', '$(max:)');
.               elsif mode = "hex"
    build_charmap_for_range (CMAP_$(set.NAME), 0x$(min:), 0x$(max:));
.               elsif mode = "dec"
    build_charmap_for_range (CMAP_$(set.NAME), $(min:), $(max:));
.               else
.                  abort "bad mode for set '$(set.name)'"
.               endif
.           endif
.           for except
    build_charmap_for_except (CMAP_$(set.NAME), "$(value:)");
.           endfor
.       endfor
.   endfor
}


.endmacro



----->    SUB MACROS FOR 'function_definitions' MACRO
.macro define_main_parse_function
/***************************************************************************/
int new_import_table (char *table)
{
    XML_ITEM
        *root;
    XML_BUFFER
        *buf;
    char
        *table_name,
        row_buf   [50],
        error_msg [1024];
    int
        res = -1;
    Bool
        parsed;

    ASSERT (table);

    sprintf (db_globals.file_name, "%s.xml", table);

    if (!file_exists (db_globals.file_name))
      {
        sprintf (error_msg, "name=\\"%s\\"", strlwc (table));
        fprintf (out_file,
                "<table %-25s warning=\\"1\\" message=\\"file is missing\\" />\\n",
                error_msg);
        return XML_NOERROR;
      }

    if (dropall)
        drop_all_record (table);

#ifdef DB_ODBC
    if (incremental_import)
      {
        table_name = get_real_table_name (&table_list, table);
        if (table_name)
          {
            primary_key = get_pk_name (table_name);
            if (primary_key == NULL)
              {
                primary_key = get_pk_name_from_list (table_name);

                if (primary_key == NULL)
                  {
                    fprintf (out_file,
                        "<table name=\\"%s\\" warning=\\"1\\" message=\\"%s: missing primary key\\" />\\n",
                        strlwc (table), table);
                    return XML_NOERROR;
                  }
              }
           }
      }
#endif
    buf = buf_init_from_file (db_globals.file_name, error_msg);

    if (buf)
      {
        list_reset (&db_globals.col_list);

        root = alloc_xml_item ();

        init_charmaps ();
        db_globals.recno = 0;
        db_globals.db_error = FALSE;

.   if count (root.item, defined (main)) <> 1
.       abort "exaclty one item must have the 'main' attribute defined"
.   endif
.   for root.item where defined (main)
        parsed = parse_$(item.name) (buf, MODE_ONCE, root);
.   endfor

        if (parsed )
          {
            res = 0;
#ifdef DB_ODBC
            if (have_identity)
              {
                SQLFreeStmt (h_statement, SQL_UNBIND);
                SQLFreeStmt (h_statement, SQL_CLOSE);
                sprintf (db_globals.file_name, "SET IDENTITY_INSERT %s OFF", db_globals.table_name);
                return_code = SQLExecDirect (h_statement, db_globals.file_name, SQL_NTS);
                if (return_code != SQL_SUCCESS
                &&  return_code != SQL_SUCCESS_WITH_INFO)
                  {
                    get_db_error_message ();
                    res = -1;
                  }
              }
#endif
          }
        else
        if (!db_globals.db_error)
            printf ("xml file is not well-formed");

        buf_dispose (&buf);

        sprintf (error_msg, "name=\\"%s\\"", strlwc (table));
        sprintf (row_buf,   "rows=\\"%ld\\"", db_globals.recno);
        fprintf (out_file, "<table %-25s %-11s/>\\n", error_msg, row_buf);

        free_all_columns_name (&db_globals.col_list);
        xml_free (root);
        fflush (out_file);
      }
    else
      {
        fprintf (out_file, "<table name=\\"%s\\" error=\\"1\\" row=\\"%ld\\" message=\\"%s\\" />\\n",
                           strlwc (table),
                           db_globals.recno + 1,
                           error_msg);
      }

    free_all_columns_name (&columns);
    free_all_index_name   (&index_list);

    return res;
}


.endmacro





----->    SUB MACROS FOR 'function_definitions' MACRO
.macro define_parse_item_functions
.   for item
/***************************************************************************/
.       if defined (parent_struct)
Bool parse_$(name) (XML_BUFFER *buf, int mode, $(parent_struct:) *parent_struct)
.       else
Bool parse_$(name) (XML_BUFFER *buf, int mode)
.       endif
{
    ENABLE_TRY
    int
            hit;
    Bool
            res;
.   declare_try_ch ()
.       if defined (child_struct)
.           if !defined (create_child) | !defined (free_child) | !defined (attach_child)
.               abort "create_child - free_child AND/OR attach_child is missing for $(item.name)"
.           endif
    $(child_struct:)
            *child_struct = NULL;
.       endif

.       if defined (parent_struct)
    ASSERT (parent_struct);

.       endif
    switch (mode)
      {
        case MODE_ONCE:
.       if defined (child_struct)
            child_struct = $(create_child:)();
            if (!child_struct)
              {
                /* XXX TODO : management of an error message - exhausted memory */
                /* If this happen, we can assume it is THE actual error */
                res = FALSE;
                break;
              }
.       endif
.           generate_code_for_once ()
            break;


        default:
            ASSERT ( (mode == MODE_ZERO_OR_MORE)
                  || (mode == MODE_ONCE_OR_MORE)
                  || (mode == MODE_OPTIONAL) );
            hit = 0;
            FOREVER
              {
.       if defined (parent_struct)
                TRY(parse_$(name)(buf, MODE_ONCE, parent_struct));
.       else
                TRY(parse_$(name)(buf, MODE_ONCE));
.       endif
                if (TRY_FAILED)
                    break;

                hit++;

                if (mode == MODE_OPTIONAL)
                    break;
              }
            res = (mode == MODE_ONCE_OR_MORE)
                        ? (hit >= 1)
                        : TRUE;
            break;
      }

.       if defined (child_struct)
.           .attach_error_code ?= "NO_ERROR_MSG"
    if (mode == MODE_ONCE)
      {
        ASSERT (child_struct);
        if (res)
          {
.           if defined (parent_struct)
            res = $(attach_child:) (parent_struct, child_struct);
.           else
            res = $(attach_child:) (NULL, child_struct);
.           endif
            if (!res)
                set_error (buf, $(attach_error_code:))
          }
        else
            $(free_child:) (child_struct);
      }

.       endif
    return res;
}


.   endfor
.endmacro


----->    SUB MACROS FOR 'function_definitions' MACRO
.macro declare_try_ch
.   if count (component, type = "char_in_set") > 0
    char
            try_ch;
.   endif
.endmacro



----->    SUB MACROS FOR 'function_definitions' MACRO
.macro generate_code_for_once
.   root.type = type ? "union"
.   if root.type = "union"
            res = FALSE;
.   elsif root.type = "disjunct"
            res = TRUE;
.   else
.       abort
.   endif
.   for component
.       component.count ?= "once"
.       count = "MODE_$(COUNT)"
.       if defined (.handler)
.           generate_try_handler ()
.       else
.           generate_try ()
.       endif
.   endfor
.   if root.type = "union"
            res = TRUE;
.   elsif root.type = "disjunct"
            res = FALSE;
.   else
.       abort
.   endif
.endmacro


----->    SUB MACROS FOR 'function_definitions' MACRO
.macro generate_try
.   if type = "item"
.       if defined (fills)
            TRY (parse_$(name) (buf, $(COUNT), $(fills:)));
.       else
            TRY (parse_$(name) (buf, $(COUNT)));
.       endif
.   elsif type = "constant_char"
            TRY (parse_one_char (buf, \'$(value:)\'));
.   elsif type = "constant_string"
            TRY (parse_constant_string (buf, \"$(value:)\"));
.   elsif type = "any_before_char"
.       .allow_empty ?= "FALSE"
            TRY (parse_any_before_char (buf, \'$(value:)\', $(allow_empty:)));
.   elsif type = "any_before_string"
            TRY (parse_any_before_string (buf, \"$(value:)\"));
.   elsif type = "union" | type = "disjunct"
.       if defined (child_struct)
            TRY (parse_group_$(nr) (buf, $(COUNT), child_struct));
.       elsif defined (parent_struct)
            TRY (parse_group_$(nr) (buf, $(COUNT), parent_struct));
.       else
            TRY (parse_group_$(nr) (buf, $(COUNT)));
.       endif
.   elsif type = "char_in_set"
            TRY_IS ($(name));
.   else
.       abort "unrecognized type for item $(item.name)"
.   endif
.   if root.type = "union"
            if (TRY_FAILED)
                break;
.   elsif root.type = "disjunct"
            if (TRY_SUCCEED)
                break;
.   else
.       abort
.   endif
.endmacro


----->    SUB MACROS FOR 'function_definitions' MACRO
.macro generate_try_handler
.   if !defined (.handler)
.       abort "assertion failed 1 - $(name)"
.   endif
.   if defined (.fills)
.       abort "'handler' and 'fills' cannot both be defined for component $(name)"
.   endif
.   .decode_http ?= "FALSE"
.   .handler_error_code ?= "NO_ERROR_MSG"
.   if defined (child_struct)
.       root.struct_to_fill = "child_struct"
.   elsif defined (parent_struct)
.       root.struct_to_fill = "parent_struct"
.   else
.       abort "handler must be applied to a parent or a child struct. ($(name))"
.   endif
.   if type = "item"
            TRY_HANDLER (parse_$(name) (buf, $(COUNT)),
                         $(handler:),
                         $(root.struct_to_fill:),
                         $(decode_http:),
                         $(handler_error_code:));
.   elsif type = "union"
            TRY_HANDLER (parse_group_$(nr) (buf, $(COUNT)),
                         $(handler:),
                         $(root.struct_to_fill:),
                         $(decode_http:),
                         $(handler_error_code:));
.   elsif type = "any_before_char"
.       .allow_empty ?= "FALSE"
            TRY_HANDLER (parse_any_before_char (buf, \'$(value:)\', $(allow_empty:)),
                         $(handler:),
                         $(root.struct_to_fill:),
                         $(decode_http:),
                         $(handler_error_code:));
.   elsif type = "any_before_string"
            TRY_HANDLER (parse_any_before_string (buf, \"$(value:)\"),
                         $(handler:),
                         $(root.struct_to_fill:),
                         $(decode_http:),
                         $(handler_error_code:));
.   elsif type = "constant_string"
            TRY_HANDLER (parse_constant_string (buf, \"$(value:)\"),
                         $(handler:),
                         $(root.struct_to_fill:),
                         $(decode_http:),
                         $(handler_error_code:));
.   else
.       abort "handler cannot be defined for type '$(type:)' ($(name:))"
.   endif
.   if root.type = "union"
            if (TRY_FAILED)
                break;
.   elsif root.type = "disjunct"
            if (TRY_SUCCEED)
                break;
.   else
.       abort "assertion failed : root.type should be 'union' or 'disjunct'"
.   endif
.endmacro






----->    SUB MACROS FOR 'function_definitions' MACRO
.macro define_parse_group_functions
.   for component
.       if type = "union" | type = "disjunct"
.           define_one_parse_group_function ()
.           define_parse_group_functions ()
.       endif
.   endfor
.endmacro


----->    SUB MACROS FOR 'function_definitions' MACRO
.macro define_one_parse_group_function
.   count ?= "once"
/***************************************************************************/
/* $(TYPE) */
.   if defined (parent_struct) & !defined (handler)
Bool parse_group_$(nr) (XML_BUFFER *buf, int mode, $(parent_struct:) *parent_struct)
.   else
Bool parse_group_$(nr) (XML_BUFFER *buf, int mode)
.   endif
{
    ENABLE_TRY
    int
            hit;
.   declare_try_ch ()
    Bool
            res;

    switch (mode)
      {
        case MODE_ONCE:
.           generate_code_for_once ()
            break;


        default:
            ASSERT ( (mode == MODE_ZERO_OR_MORE)
                  || (mode == MODE_ONCE_OR_MORE)
                  || (mode == MODE_OPTIONAL) );
            hit = 0;
            FOREVER
              {
.   if defined (parent_struct) & !defined (handler)
                TRY(parse_group_$(nr) (buf, MODE_ONCE, parent_struct));
.   else
                TRY(parse_group_$(nr) (buf, MODE_ONCE));
.   endif
                if (TRY_FAILED)
                    break;

                hit++;

                if (mode == MODE_OPTIONAL)
                    break;
              }
            res = (mode == MODE_ONCE_OR_MORE)
                        ? (hit >= 1)
                        : TRUE;
            break;
      }

    return res;
}


.endmacro



----->    SUB MACROS FOR 'function_definitions' MACRO
.macro define_general_parse_functions
Bool parse_one_char(XML_BUFFER *buf, const char ch)
{
    char
        buf_ch;

    ASSERT (buf);

    get_next_char (buf, buf_ch);

    if (ch == buf_ch)
        return TRUE;
    else
      {
        if (cur_ctxt(buf).pos > buf-> error_ctxt.pos)
            set_error (buf, UNEXPECTED_CHAR);
        return FALSE;
      }
}

Bool parse_constant_string (XML_BUFFER *buf, const char * str)
{
    const char
            *ch;
    char
        buf_ch;

    ASSERT (buf);
    ASSERT (str);

    for (ch = str; *ch; ch++)
      {
        get_next_char (buf, buf_ch);
        if ( buf_ch != *ch)
          {
            set_error (buf, UNEXPECTED_CHAR);
            return FALSE;
          }
      }

    return TRUE;
}


/* returns TRUE if at least one char has been found before 'ch' */
Bool parse_any_before_char (XML_BUFFER *buf, const char ch, Bool allow_empty)
{
    char
        *from,
        *to,
        *found = NULL;
    int
        new_pos,
        new_line;

    ASSERT (buf);
    ASSERT (ch != 0);

    ASSERT (buf-> cache_cur_ptr
                  ? buf-> cache_cur_ptr >= buf-> cache
                  : TRUE);
    ASSERT (buf-> cache_cur_ptr <= buf-> cache_last_ptr);
    if ( !buf-> cache_cur_ptr
            || (buf-> cache_cur_ptr == buf-> cache_last_ptr) )
      {
        handle_page_fault (buf);
        if (!buf-> cache_cur_ptr)
          {
            set_error (buf, UNEXPECTED_EOF);
            return FALSE;
          }
      }

    new_line = cur_ctxt(buf).line;

    /* here, the cache is valid and not consumed */
    FOREVER
      {
        ASSERT (buf-> cache_last_ptr > buf-> cache_cur_ptr);
        found = memchr (buf-> cache_cur_ptr,
                        ch,
                        buf-> cache_last_ptr - buf-> cache_cur_ptr);

        to = found
                ? found
                : buf-> cache_last_ptr;
        ASSERT (buf-> cache_cur_ptr <= to);
        for (from=buf-> cache_cur_ptr; from != to; from++)
            if (*from == '\\r')
                new_line++;

        if ( found )
          {
            buf-> cache_cur_ptr = found;
            ASSERT (buf-> cache_cur_ptr >= buf-> cache);
            new_pos = buf-> cache_offset + (buf-> cache_cur_ptr - buf-> cache);
            ASSERT (new_pos >= cur_ctxt(buf).pos);
            if (new_pos == cur_ctxt(buf).pos)
              {
                /* buffer was already pointing to the searched char */
                if (allow_empty)
                    return TRUE;
                else
                  {
                    set_error (buf, UNEXPECTED_CHAR);
                    return FALSE;
                  }
              }
            else
              {
                cur_ctxt(buf).pos  = new_pos;
                cur_ctxt(buf).line = new_line;
                return TRUE;
              }
          }

        /* not in cache */
        buf-> cache_cur_ptr = buf-> cache_last_ptr;  /* causes page fault */
        handle_page_fault (buf);
        if (!buf-> cache_cur_ptr)
          {
            /* we reached EOF or an error occured */
            set_error (buf, UNEXPECTED_EOF);
            return FALSE;
          }
      }
}


Bool parse_any_before_string (XML_BUFFER *buf, const char *str)
{
    char
        *from,
        *to,
        *found;
    int
        length,
        new_pos,
        new_line;

    ASSERT (buf);
    ASSERT (str);
    length = strlen (str);
    ASSERT (length > 0);
    ASSERT (length < HALF_XML_BUFFER_SIZE);  /* XXX needs discussion */

    ASSERT (buf-> cache_cur_ptr
                  ? buf-> cache_cur_ptr >= buf-> cache
                  : TRUE);
    ASSERT (buf-> cache_cur_ptr <= buf-> cache_last_ptr);
    if ( !buf-> cache_cur_ptr
            || (buf-> cache_cur_ptr == buf-> cache_last_ptr) )
      {
        handle_page_fault (buf);
        if (!buf-> cache_cur_ptr)
          {
            set_error (buf, UNEXPECTED_EOF);
            return FALSE;
          }
      }

    new_line = cur_ctxt(buf).line;

    /* here, the cache is valid and not consumed */
    FOREVER
      {
        ASSERT (buf-> cache_last_ptr > buf-> cache_cur_ptr);
        ASSERT (buf-> cache[XML_BUFFER_SIZE] == 0);  /* cache must be terminated
                                                  * like a string */
        found = strstr (buf-> cache_cur_ptr, str);

        to = found
                ? found
                : buf-> cache_last_ptr - length;
        ASSERT (buf-> cache_cur_ptr <= to);
        for (from=buf-> cache_cur_ptr; from != to; from++)
            if (*from == '\\r')
                new_line++;

        if ( found )
          {
            buf-> cache_cur_ptr = found;
            ASSERT (buf-> cache_cur_ptr >= buf-> cache);

            new_pos = buf-> cache_offset + (buf-> cache_cur_ptr - buf-> cache);
            ASSERT (new_pos >= cur_ctxt(buf).pos);
            if (new_pos == cur_ctxt(buf).pos)
              {
                set_error (buf, UNEXPECTED_CHAR);
                return FALSE;
              }
            else
              {
                cur_ctxt(buf).pos  = new_pos;
                cur_ctxt(buf).line = new_line;
                return TRUE;
              }
          }

        /* not in cache */
        buf-> cache_cur_ptr = buf-> cache_last_ptr;  /* causes page fault */
        handle_page_fault (buf);
        if (!buf-> cache_cur_ptr)
          {
            /* we reached EOF or an error occured */
            set_error (buf, UNEXPECTED_EOF);
            return FALSE;
          }
        ASSERT (buf-> cache_cur_ptr - buf-> cache == HALF_XML_BUFFER_SIZE);
        buf-> cache_cur_ptr -= length;  /* insure we won't skip str */
      }
}

.endmacro




.macro define_xml_buffer_functions
XML_BUFFER *buf_init_from_file (const char *fullpath, char *error_msg)
{
    #define DISPOSE_AND_RETURN_NULL                                         \\
      {                                                                     \\
        if (file)                                                           \\
            fclose (file);                                                  \\
        if (res)                                                            \\
          {                                                                 \\
            if (res-> cache)                                                \\
                mem_free (res-> cache);                                     \\
            mem_free (res);                                                 \\
          }                                                                 \\
        return NULL;                                                        \\
      }

    FILE
            *file = NULL;
    XML_BUFFER
            *res = NULL;
    Bool
            error = FALSE;

    ASSERT (fullpath);

    file = file_open(fullpath, 'r');
    if (!file)
      {
        if (error_msg)
            sprintf (error_msg, "Could not open XML file : %s", fullpath);
        DISPOSE_AND_RETURN_NULL
      }
    res = (XML_BUFFER *) mem_alloc (sizeof(XML_BUFFER));
    if (!res)
      {
        if (error_msg)
            strcpy (error_msg, "Not enough memory on the heap");
        DISPOSE_AND_RETURN_NULL
      }

    res-> file_size = get_file_size (fullpath);
    if (res-> file_size <= 0)
        DISPOSE_AND_RETURN_NULL

    res-> cache = (char*) mem_alloc (XML_BUFFER_SIZE+1);
    if (!res-> cache)
      {
        if (error_msg)
            strcpy (error_msg, "Not enough memory on the heap");
        DISPOSE_AND_RETURN_NULL
      }

    res-> cache[XML_BUFFER_SIZE] = 0;  /* for the cache to be a string */
    res->fd = file;
    res-> cache_cur_ptr  = NULL;
    res-> cache_last_ptr = NULL;
    res-> stack          = (XML_CONTEXT *) mem_alloc (STACK_DEPTH * sizeof(XML_CONTEXT));
    res-> stack_depth    = STACK_DEPTH;
    res-> stack_top      = 0;
    cur_ctxt(res).pos    = 0;
    cur_ctxt(res).line   = 0;
    res-> cache_offset   = 0;
    res-> error_ctxt.pos  = -1;
    res-> error_ctxt.line = -1;
    res-> filename  = fullpath;
    res-> error_msg = error_msg;
    res-> error_code = NO_ERROR_MSG;
    if (error_msg)
        error_msg[0];

    return res;

    #undef DISPOSE_AND_RETURN_NULL
}

XML_BUFFER *buf_init_from_string (const char *xmlstring)
{
    #define DISPOSE_AND_RETURN_NULL                                         \\
      {                                                                     \\
        if (res)                                                            \\
          {                                                                 \\
            if (res-> cache)                                                \\
                mem_free (res-> cache);                                     \\
            mem_free (res);                                                 \\
          }                                                                 \\
        return NULL;                                                        \\
      }

    XML_BUFFER
            *res = NULL;
    Bool
            error = FALSE;

    if (!xmlstring || (strlen (xmlstring) == 0))
        return NULL;


    res = (XML_BUFFER *) mem_alloc (sizeof(XML_BUFFER));
    if (!res)
        return NULL;

    /* NO use of strdupl for compatibility (strfree VS mem_free when disposing) */
    res-> cache = (char*) mem_alloc (strlen(xmlstring) + 1);
    if (!res-> cache)
        DISPOSE_AND_RETURN_NULL
    strcpy (res-> cache, xmlstring);

    res-> cache_size = strlen (xmlstring);
    res-> file_size = res-> cache_size;
    res->fd = NULL;
    res-> cache_cur_ptr  = res-> cache;
    res-> cache_last_ptr = &res-> cache[res-> cache_size];
    res-> stack          = (XML_CONTEXT *) mem_alloc (STACK_DEPTH * sizeof(XML_CONTEXT));
    res-> stack_depth    = STACK_DEPTH;
    res-> stack_top      = 0;
    cur_ctxt(res).pos    = 0;
    cur_ctxt(res).line   = 0;
    res-> cache_offset   = 0;
    res-> error_ctxt.pos  = -1;
    res-> error_ctxt.line = -1;
    res-> filename  = NULL;
    res-> error_msg = NULL;
    res-> error_code = NO_ERROR_MSG;

    return res;

    #undef DISPOSE_AND_RETURN_NULL
}


char *get_string (XML_BUFFER *buf, Bool decode_http)
{
    char
        *res = NULL,
        *src,
        *cur,
        *dst;
    int
        offset,
        tab_count,
        size;
    char
        saved;

    ASSERT (buf);
    ASSERT (buf-> stack);
    ASSERT (buf-> stack_top > 0);      /* at least one context saved in stack */
    ASSERT (buf-> stack[buf-> stack_top - 1].pos <= cur_ctxt(buf).pos);
    ASSERT (buf-> cache_cur_ptr);


    src = buf-> cache_cur_ptr - (cur_ctxt(buf).pos - buf-> stack[buf-> stack_top-1].pos);
    saved = *buf-> cache_cur_ptr;
    *buf-> cache_cur_ptr = 0;

    /* 'src' points to the string that will be copied for result.
     *
     * the copy could be different, because
     * 1) CR-LF ----> CR
     * 2) TAB are expanded to space chars.
     *
     * For tab expansion, management is quite heavy, because we have to
     * find the start of the line in order to know how a TAB will be expanded.
     * We'll avoid the TAB expansion management if no TAB characters are
     * present in 'src'  */


    /* For backward compatibility, we don't change original string when buf is
       initialized from string, i.e. that tabs are not expanded, and CR-LFs
       don't change */
    if (!buf-> filename)
      {
        res = (char *) mem_alloc (strlen (src) + 1);
        if (res)
            strcpy (res, src);
        *buf-> cache_cur_ptr = saved;
        return res;
      }

    tab_count = 0;
    for (cur=src; *cur; cur++)
        if (*cur == '\\t')
            tab_count++;

    if (tab_count > 0)
      {
        /* 1. We search start of line or TAB before src */
        cur = src;
        offset = 0;
        if (*cur != '\\n')
          {
            FOREVER
              {
                cur--;
                if (cur < buf-> cache)
                  {
                    /* we're outside the cache.*/
                    if (buf-> cache_offset == 0)
                        /* we were on the first line of the file */
                        break;
                    else
                      {
                        /* this is a very bad case, but it should be rare */
                        // TODO : reloading cache management !!!
                        ASSERT (FALSE);
                      }
                  }
                else
                  {
                    if ( (*cur == '\\t') || (*cur == '\\n') )
                        /* we found a char from which we can compute TAB expansion */
                        break;
                    else
                      offset++;
                  }
              }
          }


        /* 2. we allocate the string. We use the src size + tab_count,
         * to be sure the string will be long enough.
         * Note : some extra memory may be allocated, but if we want to compute the
         * exact size, we need an extra pass
         * ONE tab will need TAB_EXPANSION - 1 extra char for space extension
         * ( -1 because the tab char will be REPLACED by a space ) */
        size = strlen(src) + (tab_count * (TAB_EXPANSION-1));
        res = (char *) mem_alloc (size + 1);
        ASSERT (res);       // TO DO : error management
        dst = res;

        /* we copy the source to result, expanding TAB to spaces,
         * and ignoring CR... */
        for (cur=src; *cur; cur++)
          {
            if (*cur != '\\r')
              {
                if (*cur == '\\t')
                  {
                    memset (dst, ' ', TAB_EXPANSION - (offset%TAB_EXPANSION));
                    dst += TAB_EXPANSION - (offset%TAB_EXPANSION);
                    offset = 0;
                  }
                else
                  {
                    *dst++ = *cur;
                    if (*cur == '\\n')
                        offset = 0;
                    else
                        offset++;
                  }
              }
          }
        *dst = 0;
      }
    else
      {
        res = (char *) mem_alloc (strlen (src) + 1);
        ASSERT (res);       // TO DO : error management
        dst = res;

        for (cur=src; *cur; cur++)
            if (*cur != '\\r')
                *dst++ = *cur;
        *dst = 0;

        ASSERT (dst >= res);
        ASSERT (strlen(res) == (size_t)(dst - res));
      }

    if (decode_http)
      {
        /* Using directly 'res' as argument is not safe because 'res' is
         * modified by http_decode_meta. */
        src = res;
        http_decode_meta (src, &src, dst-src+1);
      }

    *buf-> cache_cur_ptr = saved;

    return res;
}




void buf_dispose (XML_BUFFER **buf)
{
    ASSERT (buf);

    if (*buf)
      {
        if ((*buf)-> fd)
          {
            if (fclose ((*buf)-> fd) && (*buf)-> error_msg)
                strcpy ((*buf)-> error_msg, "Error closing file");
          }
        if ((*buf)-> stack)
            mem_free ((*buf)-> stack);

        mem_free ( (*buf)-> cache);
        mem_free (*buf);
        *buf = NULL;
      }
}

void handle_page_fault (XML_BUFFER *buf)
{
    long
        offset;
    char
        *half;

    ASSERT (buf);

    if (!buf->filename)
      {
        /*  buffer had been initialized from string
            --> no cache management */
        buf-> cache_cur_ptr = NULL;
        return;
      }


    ASSERT (buf-> fd);

    if (buf-> cache_cur_ptr)
      {
        /* we check whether the entire file has been handled */
        if (buf-> cache_offset + buf-> cache_size == buf-> file_size)
          {
            /* EOF has been reached */
            buf-> cache_cur_ptr = NULL;
            return ;
          }

        /* we keep half of the cache */
        ASSERT (buf-> cache_last_ptr);
        ASSERT (buf-> cache_cur_ptr == buf-> cache_last_ptr);
        /* copy 2nd half of cache on 1st half */
        half = &buf-> cache[HALF_XML_BUFFER_SIZE];
        memcpy (buf-> cache, half, HALF_XML_BUFFER_SIZE);
        /* read 2nd half from file */
        buf-> cache_size = HALF_XML_BUFFER_SIZE
                        + fread (&buf-> cache[HALF_XML_BUFFER_SIZE],
                                 1,
                                 HALF_XML_BUFFER_SIZE,
                                 buf-> fd);

        buf-> cache_cur_ptr = &buf-> cache[HALF_XML_BUFFER_SIZE];
        buf-> cache_last_ptr = &buf-> cache[buf-> cache_size];
        buf-> cache_last_ptr[0] = 0;
        buf-> cache_offset += HALF_XML_BUFFER_SIZE;
      }
    else
      {
        /* cache is not valid at all. */
        ASSERT (cur_ctxt(buf).pos <= buf-> file_size);

        if (cur_ctxt(buf).pos == buf-> file_size)  /* End of file */
          {
            buf-> cache_cur_ptr = NULL;
            return;
          }

        offset = cur_ctxt(buf).pos - HALF_XML_BUFFER_SIZE;
        offset = max (offset, 0);
        fseek (buf-> fd, offset, SEEK_SET);

        buf-> cache_size = fread (buf-> cache, 1, XML_BUFFER_SIZE, buf-> fd);

        buf-> cache_last_ptr = &buf-> cache[buf-> cache_size];
        buf-> cache_last_ptr[0] = 0;
        buf-> cache_offset = offset;
        buf-> cache_cur_ptr = buf-> cache + (cur_ctxt(buf).pos - offset);
      }

    if ( buf-> cache_size < XML_BUFFER_SIZE )
      {
        ASSERT (buf-> cache_offset + buf-> cache_size <= buf-> file_size);
        if (buf-> cache_offset + buf-> cache_size < buf-> file_size)
            /* fread failed for some unknown reason (not EOF)
             * --> we invalidate the cache */
            buf-> cache_cur_ptr = NULL;
      }
}

char *build_error_message  (XML_BUFFER *buf)
{
    char
        *start,
        *end,
        saved;
    int
        length;

    ASSERT (buf);
    ASSERT (buf-> error_code != NO_ERROR_MSG);

    if (!buf-> error_msg)
        return NULL;

    buf-> error_msg[0] = 0;

    ASSERT (buf-> fd);

    /* we force the cache to be reloaded with current error line */
    buf-> error_ctxt.pos --;  /* XXX due to get_next_char who increments cache_cur_ptr */
    memcpy ( &cur_ctxt(buf), &buf-> error_ctxt, sizeof (XML_CONTEXT));
    buf-> cache_cur_ptr = NULL;
    handle_page_fault (buf);

    if (buf-> cache_cur_ptr)
      {
        /* we search the start of the line containing the error */
        ASSERT (buf-> cache_cur_ptr >= buf-> cache);
        start = buf-> cache_cur_ptr - 1;
        while ( (start >= buf-> cache)
                    && (*start != '\\r')
                    && (*start != '\\n') )
            start--;

        start++;
        ASSERT (start >= buf-> cache);
        ASSERT (start < buf-> cache_last_ptr);

        end = buf-> cache_cur_ptr;
        while ( (end < buf-> cache_last_ptr)
                && (*end != '\\r')
                && (*end != '\\n') )
            end++;

        saved = *end;
        *end = 0;
        /* XXX todo : error code management */
        sprintf (buf-> error_msg, "%s (%i): %s\\n",
                    buf-> filename,
                    cur_ctxt(buf).line + 1,
                    start );
        *end = saved;
      }

    length = strlen (buf-> error_msg);
    ASSERT (length >= 0);
    sprintf (&buf-> error_msg[length], error_messages[buf-> error_code]);

    /* XXXXX  just for debug purpoises */
    if (buf-> cache_cur_ptr)
      {
        length = strlen (buf-> error_msg);
        sprintf (&buf-> error_msg[length], "\\nFAULTY CHAR   : %c", *buf-> cache_cur_ptr);
        length = strlen (buf-> error_msg);
        saved = *end;
        *end = 0;
        sprintf (&buf-> error_msg[length], "\\nFAULTY STRING : %s", buf-> cache_cur_ptr);
        *end = saved;
      }

    return buf-> error_msg;
}


.endmacro



----------------------------------------------------------------------------
.macro declare_main_parse_function ()
int new_import_table (char *table_name);

.endmacro





----------------------------------------------------------------------
---------------------------- MAIN GSL CODE ---------------------------
----------------------------------------------------------------------
xml from "dbpars.xml"

output "dbpars.c"
header                  ()
-define_include          ()
declare_cmap_functions  ()
declare_main_parse_function ()
define_global_var       ()
define_item_management  ()
define_mode_constants   ()
define_error_messages   ()
define_xml_buffer       ()
define_try_mechanism    ()
define_cmap             ()
function_declarations   ()
function_definitions    ()



