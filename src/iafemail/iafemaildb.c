/*  ----------------------------------------------------------------<Prolog>-
    Name:       iafemaildb.c
    Title:      dotBEER Email Daemon Database Access

    Generated by eslservice at 2003/02/19 11:49:23

    Synopsis:   Get data from email log and email queue

    This program is copyright (c) 1991-2001 iMatix Corporation.
    ---------------------------------------------------------------</prolog>-*/

#include "sfl.h"
#include <sqlext.h>
#include "iafemaildb.h"

/*- Definition --------------------------------------------------------------*/

#define ERR_MSG_SIZE           300
#define ERR_CODE_SIZE          20

/*- Global Variable ---------------------------------------------------------*/

HENV  
    environment = NULL;                /*  ODBC environment                 */
HDBC
    connection  = NULL;                /*  ODBC connection handle           */
HSTMT
    log_stmt    = NULL,                /* ODBC Statement handle             */
    queue_stmt  = NULL;                /* ODBC Statement handle             */
RETCODE
    rc,
    retcode;
int
    feedback,                          /* feedback value                    */
    err_code;                          /* Error code ( 0 = NO ERROR)        */
static char
    err_code_msg [ERR_CODE_SIZE],      /* Error Message code                */
    err_message  [ERR_MSG_SIZE];       /* Error message                     */

    long   h_dbid;
    long   h_dbsender;
    char   h_dbrecipients [50 + 1];
    char   h_dbsubject [150 + 1];
    char   h_dbbody [8000 + 1];
    long   h_dbstatus;
    char   h_dbmessage [8000 + 1];
    double h_dbsentat;
    double h_dbcreatedts;
    long   h_dbid;
    double h_dbsendat;
    long   h_dbemaillogid;
    double h_dbrevisedts;

static SDWORD h_dbrecipients_ind
    ,h_dbsubject_ind
    ,h_dbbody_ind
    ,h_dbmessage_ind
    ;

/*- Local function declaration ---------------------------------------------*/

static int check_sql_error  (HSTMT statement);
void       prepare_log_data (IAFEMAILLOG *record);

/*##########################################################################*/
/*######################### COMMON FUNCTIONS ###############################*/
/*##########################################################################*/

/*  ---------------------------------------------------------------------[<]-
    Function: iafemail_connect

    Synopsis: Connect to a odbc database.
    ---------------------------------------------------------------------[>]-*/

Bool 
iafemail_connect (char *name, char *user, char *pwd)
{
    Bool
        feedback = FALSE;
    ASSERT (name);

    retcode = SQLAllocEnv (&environment); /* Environment handle              */
    if (retcode != SQL_SUCCESS)
      {
        coprintf ("Error: iafemail_connect (SQLAllocEnv) of %s (%ld)",
                  name, retcode);
        return (FALSE);
      }
    retcode = SQLAllocConnect (environment, &connection);
    if (retcode == SQL_SUCCESS
    ||  retcode == SQL_SUCCESS_WITH_INFO)
      {
        /* Set login timeout to 30 seconds.                                  */
        SQLSetConnectOption (connection, SQL_LOGIN_TIMEOUT, 30);
        /* Connect to data source                                            */
        retcode = SQLConnect(connection, name, SQL_NTS, user, SQL_NTS,
                             pwd, SQL_NTS);
        if (retcode != SQL_SUCCESS
        &&  retcode != SQL_SUCCESS_WITH_INFO)
          {
            check_sql_error (NULL);
            SQLFreeConnect (connection);
            SQLFreeEnv     (environment);
          }
        else
            feedback = TRUE;
      }
    else
      {
        check_sql_error (NULL);
        SQLFreeEnv (environment);
      }
    return (feedback);
}

/*  ---------------------------------------------------------------------[<]-
    Function: iafemail_disconnect

    Synopsis: 
    ---------------------------------------------------------------------[>]-*/

void
iafemail_disconnect (void)
{
    SQLDisconnect  (connection);
    SQLFreeConnect (connection);
    SQLFreeEnv     (environment);
}

/*  ---------------------------------------------------------------------[<]-
    Function: iafemail_error_message

    Synopsis: 
    ---------------------------------------------------------------------[>]-*/

char *
iafemail_error_message (void)
{
    return (err_message);
}

/*##########################################################################*/
/*######################### DBEMAILLOG FUNCTIONS #############################*/
/*##########################################################################*/

/*  ---------------------------------------------------------------------[<]-
    Function: iafemaillog_update

    Synopsis: update a record into the table DBEMAILLOG
    ---------------------------------------------------------------------[>]-*/
int
iafemaillog_update (IAFEMAILLOG *record)
{
    static char update_buffer [] =
        "UPDATE DBEMAILLOG SET "                                              \
            "  DBSENDER           = ?"                                        \
            ", DBRECIPIENTS       = ?"                                        \
            ", DBSUBJECT          = ?"                                        \
            ", DBSTATUS           = ?"                                        \
            ", DBSENTAT           = ?"                                        \
            ", DBCREATEDTS        = ?"                                        \
        " WHERE ("                                                            \
            "DBID                 = ?)";

    retcode = SQLAllocStmt (connection, &log_stmt);
    if (retcode != SQL_SUCCESS
    &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (log_stmt);
        return (feedback);         
      }
    prepare_log_data (record);

    rc = SQLPrepare (log_stmt, update_buffer, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
        rc  = SQLBindParameter (log_stmt, 1,                             SQL_PARAM_INPUT,
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_dbsender, 0,NULL);
        rc  = SQLBindParameter (log_stmt, 2,                             SQL_PARAM_INPUT,
                                SQL_C_CHAR,  SQL_LONGVARCHAR, 50, 0,
                                h_dbrecipients,  0, NULL);
        rc  = SQLBindParameter (log_stmt, 3,                             SQL_PARAM_INPUT,
                                SQL_C_CHAR,  SQL_LONGVARCHAR, 150, 0,
                                h_dbsubject,    0, NULL);
        rc  = SQLBindParameter (log_stmt, 4,                             SQL_PARAM_INPUT,
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_dbstatus, 0,NULL);
        rc  = SQLBindParameter (log_stmt, 5,                             SQL_PARAM_INPUT,
                                SQL_C_DOUBLE,  SQL_DOUBLE, 0, 0,
                                &h_dbsentat,     0, NULL);
        rc  = SQLBindParameter (log_stmt, 6,                             SQL_PARAM_INPUT,
                                SQL_C_DOUBLE,  SQL_DOUBLE, 0, 0,
                                &h_dbcreatedts,  0, NULL);
        rc  = SQLBindParameter (log_stmt, 7,                             SQL_PARAM_INPUT,
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_dbid, 0,NULL);

        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (log_stmt);
      }
    check_sql_error (log_stmt);

    SQLFreeStmt (log_stmt, SQL_DROP);
    return (feedback);
}

/*  ---------------------------------------------------------------------[<]-
    Function: iafemaillog_get

    Synopsis: get a record from the table DBEMAILLOG
    ---------------------------------------------------------------------[>]-*/

int
iafemaillog_get (IAFEMAILLOG *record)
{
    static char select_statement [] =
        "SELECT "                                                             \
         "  DBID"                                                             \
         ", DBSENDER"                                                         \
         ", DBRECIPIENTS"                                                     \
         ", DBSUBJECT"                                                        \
         ", DBBODY"                                                           \
         ", DBSTATUS"                                                         \
         ", DBMESSAGE"                                                        \
         ", DBSENTAT"                                                         \
         ", DBCREATEDTS"                                                      \
         " FROM DBEMAILLOG WHERE"                                             \
         "(DBID = ? )";
    SDWORD
        indicator;

    prepare_log_data (record);

    retcode = SQLAllocStmt (connection, &log_stmt);
    if (retcode != SQL_SUCCESS
    &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (log_stmt);
        return (feedback);         
      }
    rc = SQLPrepare (log_stmt, select_statement, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
        rc  = SQLBindParameter (log_stmt, 1,                             SQL_PARAM_INPUT,
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_dbid, 0,NULL);
        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (log_stmt);
      }
    check_sql_error (log_stmt);
    if (feedback == OK)
      {
        rc = SQLBindCol (log_stmt, 1, 
                         SQL_C_LONG,   &h_dbid, 0, &indicator);
        rc = SQLBindCol (log_stmt, 2, 
                         SQL_C_LONG,   &h_dbsender, 0, &indicator);
        rc = SQLBindCol (log_stmt, 3, 
                         SQL_C_CHAR,   &h_dbrecipients, 50 + 1, &h_dbrecipients_ind);
        rc = SQLBindCol (log_stmt, 4, 
                         SQL_C_CHAR,   &h_dbsubject, 150 + 1, &h_dbsubject_ind);
        rc = SQLBindCol (log_stmt, 5, 
                         SQL_C_CHAR,   &h_dbbody, 8000 + 1, &h_dbbody_ind);
        rc = SQLBindCol (log_stmt, 6, 
                         SQL_C_LONG,   &h_dbstatus, 0, &indicator);
        rc = SQLBindCol (log_stmt, 7, 
                         SQL_C_CHAR,   &h_dbmessage, 8000 + 1, &h_dbmessage_ind);
        rc = SQLBindCol (log_stmt, 8, 
                         SQL_C_DOUBLE, &h_dbsentat, 0, &indicator);
        rc = SQLBindCol (log_stmt, 9, 
                         SQL_C_DOUBLE, &h_dbcreatedts, 0, &indicator);
        rc = SQLFetch (log_stmt);
        if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO)
          {
            check_sql_error (log_stmt);
            feedback = RECORD_NOT_PRESENT;
          }
        else
          {
            memset (record, 0, sizeof (IAFEMAILLOG));
            record-> dbid                 = h_dbid;
            record-> dbsender             = h_dbsender;
            record-> dbstatus             = h_dbstatus;
            if (h_dbsubject_ind < 0)
                *h_dbsubject                         = '\0';
            else
                h_dbsubject [h_dbsubject_ind]        = '\0';
            strcrop (h_dbsubject);
            strcpy (record-> dbsubject,           h_dbsubject);
            if (h_dbbody_ind < 0)
                *h_dbbody                            = '\0';
            else
                h_dbbody [h_dbbody_ind]              = '\0';
            strcrop (h_dbbody);
            strcpy (record-> dbbody,              h_dbbody);
            if (h_dbrecipients_ind < 0)
                *h_dbrecipients                      = '\0';
            else
                h_dbrecipients [h_dbrecipients_ind]  = '\0';
            strcrop (h_dbrecipients);
            strcpy (record-> dbrecipients,        h_dbrecipients);
            if (h_dbmessage_ind < 0)
                *h_dbmessage                         = '\0';
            else
                h_dbmessage [h_dbmessage_ind]        = '\0';
            strcrop (h_dbmessage);
            strcpy (record-> dbmessage,           h_dbmessage);
            record-> dbsentat             = h_dbsentat;
            record-> dbcreatedts          = h_dbcreatedts;
          }
      }
    SQLFreeStmt (log_stmt, SQL_DROP);
    return (feedback);
}

/*##########################################################################*/
/*######################## EMAILQUEUE FUNCTIONS ############################*/
/*##########################################################################*/

/*  ---------------------------------------------------------------------[<]-
    Function: iafemailqueue_get

    Synopsis: Get all email queue record in alocated record table
    Return the number of record in table.
    ---------------------------------------------------------------------[>]-*/

long
iafemailqueue_get_all (double timestamp, IAFEMAILQUEUE **record)
{
    static char select_statement [] =
        "SELECT DBID, DBSENDAT, DBEMAILLOGID, DBREVISEDTS FROM DBEMAILQUEUE " \
        "WHERE (DBSENDAT <= ?) ORDER BY DBSENDAT ASC";
    static char count_statement [] =                                          \
         "SELECT count (*) FROM DBEMAILQUEUE WHERE (DBSENDAT <= ?)";
    SDWORD
        indicator;
    long
        rec_count = 0;
    IAFEMAILQUEUE
        *rec;

    h_dbsendat = timestamp; 
    retcode = SQLAllocStmt (connection, &queue_stmt);
    if (retcode != SQL_SUCCESS
    &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (queue_stmt);
        return (feedback);         
      }

    /* Get count of record                                                   */
    rc = SQLPrepare (queue_stmt, count_statement, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
        rc  = SQLBindParameter (queue_stmt, 1,                           SQL_PARAM_INPUT,
                                SQL_C_DOUBLE,  SQL_DOUBLE, 0, 0,
                                &h_dbsendat,     0, NULL);
        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (queue_stmt);
        check_sql_error (queue_stmt);
      }
    if (feedback == OK)
      {
        rc = SQLBindCol (queue_stmt, 1, 
                         SQL_C_LONG,   &rec_count, 0, &indicator);
        rc = SQLFetch (queue_stmt);
        if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO)
          {
            check_sql_error (queue_stmt);
            feedback = RECORD_NOT_PRESENT;
          }
      }


    if (rec_count > 0)
      {
        *record = mem_alloc (sizeof (IAFEMAILQUEUE) * rec_count);
        if (*record)
          {
            memset (*record, 0, sizeof (IAFEMAILQUEUE) * rec_count);

            SQLFreeStmt (queue_stmt, SQL_CLOSE);
            rc = SQLPrepare (queue_stmt, select_statement, SQL_NTS);
            if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
             {
        rc  = SQLBindParameter (queue_stmt, 1,                           SQL_PARAM_INPUT,
                                SQL_C_DOUBLE,  SQL_DOUBLE, 0, 0,
                                &h_dbsendat,     0, NULL);
               if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
                  rc = SQLExecute (queue_stmt);
               check_sql_error (queue_stmt);
             }
            rec = *record;
            while (feedback == OK)
             {
        rc = SQLBindCol (queue_stmt, 1, 
                         SQL_C_LONG,   &h_dbid, 0, &indicator);
        rc = SQLBindCol (queue_stmt, 2, 
                         SQL_C_DOUBLE, &h_dbsendat, 0, &indicator);
        rc = SQLBindCol (queue_stmt, 3, 
                         SQL_C_LONG,   &h_dbemaillogid, 0, &indicator);
        rc = SQLBindCol (queue_stmt, 4, 
                         SQL_C_DOUBLE, &h_dbrevisedts, 0, &indicator);
                rc = SQLFetch (queue_stmt);
                if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO)
                  {
                    check_sql_error (queue_stmt);
                    feedback = RECORD_NOT_PRESENT;
                  }
                else
                  {
            rec-> dbid                    = h_dbid;
            rec-> dbemaillogid            = h_dbemaillogid;
            rec-> dbsendat                = h_dbsendat;
            rec-> dbrevisedts             = h_dbrevisedts;
                  }
                rec++;
             }
          }
      }
    SQLFreeStmt (queue_stmt, SQL_DROP);

    return (rec_count);
}


/*  ---------------------------------------------------------------------[<]-
    Function: iafemailqueue_delete

    Synopsis: delete a record into the table DBEMAILQUEUE
    ---------------------------------------------------------------------[>]-*/

int
iafemailqueue_delete     (IAFEMAILQUEUE *record)
{
    HSTMT
        queue_stmt;
    static char delete_record [] =
        "DELETE FROM DBEMAILQUEUE WHERE ( "                                  \
            "DBID = ?)";
    h_dbid                = record-> dbid; 


    retcode = SQLAllocStmt (connection, &queue_stmt);
    if (retcode != SQL_SUCCESS
     &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (queue_stmt);
        return (feedback);         
      }

    rc = SQLPrepare (queue_stmt, delete_record, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
        rc  = SQLBindParameter (queue_stmt, 1,                           SQL_PARAM_INPUT,
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_dbid, 0,NULL);
        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (queue_stmt);
      }
    check_sql_error (queue_stmt);
    SQLFreeStmt (queue_stmt, SQL_DROP);
    return (feedback);         
}

/*##########################################################################*/
/*######################### INTERNAL FUNCTIONS #############################*/
/*##########################################################################*/

/*  ------------------------------------------------------------------------
    Function: check_sql_error - INTERNAL

    Synopsis: Check the SQL error
    ------------------------------------------------------------------------*/

static int
check_sql_error (HSTMT statement)
{
    long
        size;
    short
        size2;

    err_code = 0;
    
    if (rc == SQL_SUCCESS
    ||  rc == SQL_SUCCESS_WITH_INFO)
        err_code = 0;
    else
      {
        SQLError (environment, connection, statement, err_code_msg, &size,
                  err_message, ERR_MSG_SIZE - 1, &size2);
        if (strcmp (err_code_msg, "23000") == 0)
            err_code = -1;
        else
        if (strcmp (err_code_msg, "00000") == 0)
            err_code = 1;
        else
            err_code = -2;
      }

    if (err_code > 0)
      {
        feedback = RECORD_NOT_PRESENT;
      }
    else
    if (err_code == -1)
      {
        feedback = DUPLICATE_RECORD;
      }
    else
    if (err_code < 0)
      {
        feedback = HARD_ERROR;
        coprintf ("SQL Error    %d : %s", err_code, err_message);
      }
    else
        feedback = OK;

    return (feedback);
}


/*  ------------------------------------------------------------------------
    Function: prepare_log_data - INTERNAL

    Synopsis:
    ------------------------------------------------------------------------*/

static void
prepare_log_data (IAFEMAILLOG *record)
{
    h_dbid                 = record-> dbid; 
    h_dbsender             = record-> dbsender; 
    h_dbstatus             = record-> dbstatus; 
    strcpy (h_dbsubject,     record-> dbsubject);
    strcpy (h_dbbody,        record-> dbbody);
    strcpy (h_dbrecipients,  record-> dbrecipients);
    strcpy (h_dbmessage,     record-> dbmessage);
    h_dbsentat             = record-> dbsentat; 
    h_dbcreatedts          = record-> dbcreatedts; 
}
