----------------------------------------------------------------------------
-
-  Name:       eslservice.gsl
-  Title:      Generate iAf Email service
-
-  Written:    2001/03/20  Pascal Antonnaux <pascal@imatix.com>
-  Revised:    2003/02/05  Pascal Antonnaux <pascal@imatix.com>
-
----------------------------------------------------------------------------
include "mod_esl.gsl"

.############################################################################
.  macro gen_services (file_name)
.#
.# Generate main module of DXL NT/2000 service
.############################################################################
.output "$(name)db.h"
.echo   "create $(name)db.h"
/*  ----------------------------------------------------------------<Prolog>-
    Name:       $(name)db.h
    Title:      $(description:) Database Access

    Generated by eslservice at $(date) $(time)

    Synopsis:   Get data from email log and email queue

    This program is copyright (c) 1991-2001 iMatix Corporation.
    ---------------------------------------------------------------</prolog>-*/
#ifndef _$(NAME)DB_INCLUDED__
#define _$(NAME)DB_INCLUDED__

/*- Record structure --------------------------------------------------------*/

typedef struct
{
.  for log
.    for table
.      for field
.        declare_field (0, "")
.      endfor
.    endfor
.  endfor
} $(NAME)LOG;

typedef struct
{
.  for queue
.    for table
.      for field
.        declare_field (0, "")
.      endfor
.    endfor
.  endfor
} $(NAME)QUEUE;

/*- Function declaration ----------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

Bool  $(name)_connect         (char *name, char *user, char *pwd);
void  $(name)_disconnect      (void);
char *$(name)_error_message   (void);
int   $(name)log_update       ($(NAME)LOG   *record);
int   $(name)log_get          ($(NAME)LOG   *record);
long  $(name)queue_get_all    (double timestamp, $(NAME)QUEUE **record);
int   $(name)queue_delete     ($(NAME)QUEUE *record);


#ifdef __cplusplus
}
#endif

#endif
.close
.###########################################################################
.output "$(name)db.c"
.echo   "Create $(name)db.c"
/*  ----------------------------------------------------------------<Prolog>-
    Name:       $(name)db.c
    Title:      $(description:) Database Access

    Generated by eslservice at $(date) $(time)

    Synopsis:   Get data from email log and email queue

    This program is copyright (c) 1991-2001 iMatix Corporation.
    ---------------------------------------------------------------</prolog>-*/

#include "sfl.h"
#include <sqlext.h>
#include "$(name)db.h"

/*- Definition --------------------------------------------------------------*/

#define ERR_MSG_SIZE           300
#define ERR_CODE_SIZE          20

/*- Global Variable ---------------------------------------------------------*/

HENV  
    environment = NULL;                /*  ODBC environment                 */
HDBC
    connection  = NULL;                /*  ODBC connection handle           */
HSTMT
    log_stmt    = NULL,                /* ODBC Statement handle             */
    queue_stmt  = NULL;                /* ODBC Statement handle             */
RETCODE
    rc,
    retcode;
int
    feedback,                          /* feedback value                    */
    err_code;                          /* Error code ( 0 = NO ERROR)        */
static char
    err_code_msg [ERR_CODE_SIZE],      /* Error Message code                */
    err_message  [ERR_MSG_SIZE];       /* Error message                     */

.for log
.  for table
.    for field
.        declare_field (0, "h_")
.    endfor
.  endfor
.endfor
.for queue
.  for table
.    for field
.        declare_field (0, "h_")
.    endfor
.  endfor
.endfor

.comma = "static SDWORD "
.for log
.  for table
.    for field where type = "textual"
$(comma:)h_$(realname)_ind
.      comma = "    ,"
.    endfor
.  endfor
.endfor
.for queue
.  for table
.    for field where type = "textual"
$(comma:)h_$(realname)_ind
.      comma = "    ,"
.    endfor
.  endfor
.endfor
    ;

/*- Local function declaration ---------------------------------------------*/

static int check_sql_error  (HSTMT statement);
void       prepare_log_data ($(NAME)LOG *record);

/*##########################################################################*/
/*######################### COMMON FUNCTIONS ###############################*/
/*##########################################################################*/

/*  ---------------------------------------------------------------------[<]-
    Function: $(name)_connect

    Synopsis: Connect to a odbc database.
    ---------------------------------------------------------------------[>]-*/

Bool 
$(name)_connect (char *name, char *user, char *pwd)
{
    Bool
        feedback = FALSE;
    ASSERT (name);

    retcode = SQLAllocEnv (&environment); /* Environment handle              */
    if (retcode != SQL_SUCCESS)
      {
        coprintf ("Error: $(name)_connect (SQLAllocEnv) of %s (%ld)",
                  name, retcode);
        return (FALSE);
      }
    retcode = SQLAllocConnect (environment, &connection);
    if (retcode == SQL_SUCCESS
    ||  retcode == SQL_SUCCESS_WITH_INFO)
      {
        /* Set login timeout to 30 seconds.                                  */
        SQLSetConnectOption (connection, SQL_LOGIN_TIMEOUT, 30);
        /* Connect to data source                                            */
        retcode = SQLConnect(connection, name, SQL_NTS, user, SQL_NTS,
                             pwd, SQL_NTS);
        if (retcode != SQL_SUCCESS
        &&  retcode != SQL_SUCCESS_WITH_INFO)
          {
            check_sql_error (NULL);
            SQLFreeConnect (connection);
            SQLFreeEnv     (environment);
          }
        else
            feedback = TRUE;
      }
    else
      {
        check_sql_error (NULL);
        SQLFreeEnv (environment);
      }
    return (feedback);
}

/*  ---------------------------------------------------------------------[<]-
    Function: $(name)_disconnect

    Synopsis: 
    ---------------------------------------------------------------------[>]-*/

void
$(name)_disconnect (void)
{
    SQLDisconnect  (connection);
    SQLFreeConnect (connection);
    SQLFreeEnv     (environment);
}

/*  ---------------------------------------------------------------------[<]-
    Function: $(name)_error_message

    Synopsis: 
    ---------------------------------------------------------------------[>]-*/

char *
$(name)_error_message (void)
{
    return (err_message);
}

.for log
.  for table
/*##########################################################################*/
/*######################### $(REALNAME) FUNCTIONS #############################*/
/*##########################################################################*/

/*  ---------------------------------------------------------------------[<]-
    Function: $(esl.name)log_update

    Synopsis: update a record into the table $(REALNAME)
    ---------------------------------------------------------------------[>]-*/
int
$(esl.name)log_update ($(ESL.NAME)LOG *record)
{
    static char update_buffer [] =
        "UPDATE $(TABLE.REALNAME) SET "                                       \\
.    comma = "  "
.    for field where (!defined (role) | role <> "id") & (size ?< 300 | type <> "textual")
            "$(comma)$(REALNAME)  = ?"                                        \\
.      comma = ", "
.    endfor
        " WHERE ("                                                            \\
.    for field where role ?= "id"
            "$(REALNAME)          = ?)";
.    endfor

    retcode = SQLAllocStmt (connection, &log_stmt);
    if (retcode != SQL_SUCCESS
    &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (log_stmt);
        return (feedback);         
      }
    prepare_log_data (record);

    rc = SQLPrepare (log_stmt, update_buffer, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
.    bind_index = 1
.    for field where (!defined (role) | role <> "id")  & (size ?< 300 | type <> "textual")
.        bind_parameter ("log_stmt")
.    endfor
.    for field where role ?= "id"
.        bind_parameter ("log_stmt")
.    endfor

        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (log_stmt);
      }
    check_sql_error (log_stmt);

    SQLFreeStmt (log_stmt, SQL_DROP);
    return (feedback);
}

/*  ---------------------------------------------------------------------[<]-
    Function: $(esl.name)log_get

    Synopsis: get a record from the table $(TABLE.REALNAME)
    ---------------------------------------------------------------------[>]-*/

int
$(esl.name)log_get ($(ESL.NAME)LOG *record)
{
    static char select_statement [] =
        "SELECT "                                                             \\
.    comma = "  "
.    for field
         "$(comma)$(REALNAME)"                                                \\
.      comma = ", "
.    endfor
         " FROM $(TABLE.REALNAME) WHERE"                                      \\
.    for field where role ?= "id"
         "($(REALNAME) = ? )";
.    endfor
    SDWORD
        indicator;

    prepare_log_data (record);

    retcode = SQLAllocStmt (connection, &log_stmt);
    if (retcode != SQL_SUCCESS
    &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (log_stmt);
        return (feedback);         
      }
    rc = SQLPrepare (log_stmt, select_statement, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
.    bind_index = 1
.    for field where role ?= "id"
.        bind_parameter ("log_stmt")
.    endfor
        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (log_stmt);
      }
    check_sql_error (log_stmt);
    if (feedback == OK)
      {
.    bind_index = 1
.    for field
.        bind_col ("log_stmt")
.    endfor
        rc = SQLFetch (log_stmt);
        if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO)
          {
            check_sql_error (log_stmt);
            feedback = RECORD_NOT_PRESENT;
          }
        else
          {
            memset (record, 0, sizeof ($(ESL.NAME)LOG));
.           copy_to_record ("record")
          }
      }
    SQLFreeStmt (log_stmt, SQL_DROP);
    return (feedback);
}
.  endfor
.endfor

.for queue
.  for table
/*##########################################################################*/
/*######################## $(TABLE.NAME) FUNCTIONS ############################*/
/*##########################################################################*/

/*  ---------------------------------------------------------------------[<]-
    Function: $(esl.name)queue_get

    Synopsis: Get all email queue record in alocated record table
    Return the number of record in table.
    ---------------------------------------------------------------------[>]-*/

long
$(esl.name)queue_get_all (double timestamp, $(ESL.NAME)QUEUE **record)
{
    static char select_statement [] =
.    field_list = ""
.    comma = ""
.    for field
.      field_list += comma + realname
.      comma = ", " 
.    endfor
        "SELECT $(FIELD_LIST) FROM $(TABLE.REALNAME) " \\
.    for field where role ?= "sendat"
        "WHERE ($(REALNAME) <= ?) ORDER BY $(REALNAME) ASC";
    static char count_statement [] =                                          \\
         "SELECT count (*) FROM $(TABLE.REALNAME) WHERE ($(REALNAME) <= ?)";
.    endfor
    SDWORD
        indicator;
    long
        rec_count = 0;
    $(ESL.NAME)QUEUE
        *rec;

.    for field where role ?= "sendat"
    h_$(realname) = timestamp; 
.    endfor
    retcode = SQLAllocStmt (connection, &queue_stmt);
    if (retcode != SQL_SUCCESS
    &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (queue_stmt);
        return (feedback);         
      }

    /* Get count of record                                                   */
    rc = SQLPrepare (queue_stmt, count_statement, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
.    bind_index = 1
.    for field where role ?= "sendat"
.      bind_parameter ("queue_stmt")
.    endfor
        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (queue_stmt);
        check_sql_error (queue_stmt);
      }
    if (feedback == OK)
      {
        rc = SQLBindCol (queue_stmt, 1, 
                         SQL_C_LONG,   &rec_count, 0, &indicator);
        rc = SQLFetch (queue_stmt);
        if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO)
          {
            check_sql_error (queue_stmt);
            feedback = RECORD_NOT_PRESENT;
          }
      }


    if (rec_count > 0)
      {
        *record = mem_alloc (sizeof ($(ESL.NAME)QUEUE) * rec_count);
        if (*record)
          {
            memset (*record, 0, sizeof ($(ESL.NAME)QUEUE) * rec_count);

            SQLFreeStmt (queue_stmt, SQL_CLOSE);
            rc = SQLPrepare (queue_stmt, select_statement, SQL_NTS);
            if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
             {
.    bind_index = 1
.    for field where role ?= "sendat"
.      bind_parameter ("queue_stmt")
.    endfor
               if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
                  rc = SQLExecute (queue_stmt);
               check_sql_error (queue_stmt);
             }
            rec = *record;
            while (feedback == OK)
             {
.    bind_index = 1
.    for field
.      bind_col ("queue_stmt")
.    endfor
                rc = SQLFetch (queue_stmt);
                if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO)
                  {
                    check_sql_error (queue_stmt);
                    feedback = RECORD_NOT_PRESENT;
                  }
                else
                  {
.    copy_to_record ("rec")
                  }
                rec++;
             }
          }
      }
    SQLFreeStmt (queue_stmt, SQL_DROP);

    return (rec_count);
}


/*  ---------------------------------------------------------------------[<]-
    Function: $(esl.name)queue_delete

    Synopsis: delete a record into the table $(TABLE.REALNAME)
    ---------------------------------------------------------------------[>]-*/

int
$(esl.name)queue_delete  ($(ESL.NAME)QUEUE *record)
{
    HSTMT
        queue_stmt;
    static char delete_record [] =
        "DELETE FROM $(TABLE.REALNAME) WHERE ( "                             \\
.    for field where role ?= "id"
            "$(REALNAME) = ?)";
    h_$(realname)         = record-> $(realname); 
.    endfor


    retcode = SQLAllocStmt (connection, &queue_stmt);
    if (retcode != SQL_SUCCESS
     &&  retcode != SQL_SUCCESS_WITH_INFO)
      {
        check_sql_error (queue_stmt);
        return (feedback);         
      }

    rc = SQLPrepare (queue_stmt, delete_record, SQL_NTS);
    if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
      {
.    bind_index = 1
.    for field where role ?= "id"
.      bind_parameter ("queue_stmt")
.    endfor
        if (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO)
            rc = SQLExecute (queue_stmt);
      }
    check_sql_error (queue_stmt);
    SQLFreeStmt (queue_stmt, SQL_DROP);
    return (feedback);         
}
.  endfor
.endfor

/*##########################################################################*/
/*######################### INTERNAL FUNCTIONS #############################*/
/*##########################################################################*/

/*  ------------------------------------------------------------------------
    Function: check_sql_error - INTERNAL

    Synopsis: Check the SQL error
    ------------------------------------------------------------------------*/

static int
check_sql_error (HSTMT statement)
{
    long
        size;
    short
        size2;

    err_code = 0;
    
    if (rc == SQL_SUCCESS
    ||  rc == SQL_SUCCESS_WITH_INFO)
        err_code = 0;
    else
      {
        SQLError (environment, connection, statement, err_code_msg, &size,
                  err_message, ERR_MSG_SIZE - 1, &size2);
        if (strcmp (err_code_msg, "23000") == 0)
            err_code = -1;
        else
        if (strcmp (err_code_msg, "00000") == 0)
            err_code = 1;
        else
            err_code = -2;
      }

    if (err_code > 0)
      {
        feedback = RECORD_NOT_PRESENT;
      }
    else
    if (err_code == -1)
      {
        feedback = DUPLICATE_RECORD;
      }
    else
    if (err_code < 0)
      {
        feedback = HARD_ERROR;
        coprintf ("SQL Error    %d : %s", err_code, err_message);
      }
    else
        feedback = OK;

    return (feedback);
}


/*  ------------------------------------------------------------------------
    Function: prepare_log_data - INTERNAL

    Synopsis:
    ------------------------------------------------------------------------*/

static void
prepare_log_data ($(NAME)LOG *record)
{
.for log
.  for table
.    for field by type
.      if type = "textual"
.        if esl.unicode ?= 1
    wcscpy (h_$(realname),   record-> $(realname));
.        else
    strcpy (h_$(realname),   record-> $(realname));
.        endif
.      else
    h_$(realname)          = record-> $(realname); 
.      endif
.    endfor
.  endfor
.endfor
}
.close
.output "$(name).c"
.echo "Create $(name).c..."
/*  ----------------------------------------------------------------<Prolog>-
    Name:       $(name:).c
    Title:      $(description:) for Windows NT/95/98 service model

    Generated by eslservice at $(date:) $(time:)

    This program is copyright (c) 1991-2001 iMatix Corporation.
    ---------------------------------------------------------------</prolog>-*/

#include <windowsx.h>
#include <direct.h>                     /*  Directory create functions       */
#include "sfl.h"                        /*  SFL library header file          */
#include "$(name)db.h"
.if esl.unicode ?= 1
#include "iconv.h"
.endif
/*- Instance definitions ----------------------------------------------------*/

#define APPLICATION_NAME    "$(name)"     /* Name of the executable          */
#define APPLICATION_VERSION "$(version)"
#define SERVICE_NAME        "$(name)"
#define SERVICE_TEXT        "$(description:)"

/*- Global definitions ------------------------------------------------------*/

#define DEPENDENCIES      ""
#define REGISTRY_$(NAME)  "SOFTWARE\\\\imatix\\\\$(name)"
#define REGISTRY_RUN      "SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunServices"
#define WINDOWS_95        1             /*  Return from get_windows_version  */
#define WINDOWS_NT_4      2
#define WINDOWS_NT_3X     3
#define WINDOWS_2000      4

#define USAGE                                                                \\
    APPLICATION_NAME "server version " APPLICATION_VERSION ": Windows service model\\n"                          \\
    "Syntax: " APPLICATION_NAME " [options...]\\n"                            \\
    "Options:\\n"                                                             \\
    "  -i               Install Windows service\\n"                           \\
    "  -u               Uninstall Windows service\\n"                         \\
    "  -d               Run as DOS console program\\n"                        \\
    "  -h               Show summary of command-line options.\\n"             \\
    "\\nThe order of arguments is not important. Switches and filenames\\n"    \\
    "are case sensitive. See documentation for detailed information."

/*- Global variables --------------------------------------------------------*/

static SERVICE_STATUS
    service_status;                     /*  current status of the service     */
static SERVICE_STATUS_HANDLE
    service_status_handle;              /*  Service status handle             */
static HANDLE
    server_stop_event = NULL;           /*  Handle for server stop event      */
static DWORD
    error_code = 0;                     /*  Last error code                  */
static BOOL
    run_mode      = TRUE,               /*  TRUE if check request in database*/
    debug_mode    = FALSE,              /*  TRUE if debug mode               */
    console_mode  = FALSE,              /*  TRUE if console mode             */
    control_break = FALSE;              /*  TRUE if control break            */
static char
    service_name [255],                 /*  Service name                     */
    service_text [255],                 /*  Service description              */
    trace_file   [255],                 /*  Trace file name                  */
    dbname       [255],                 /*  Database Source Name             */
    dbuser       [255],                 /*  Database User                    */
    dbpwd        [255],                 /*  Database Password                */
    sender       [255],                 /*  Sender email                     */
    smtp_server  [255],                 /*  SMTP server name                 */
    user_cc      [255],                 /*  User to add in all email send    */
    user_bcc     [255],                 /*  User to add in all email send    */
    user_to      [255],                 /*  Replace the to address (debug)   */
    *rootdir,                           /*  Default root directory           */
    error_buffer [LINE_MAX + 1];        /*  Buffer for error string          */
static int
    win_version,                        /*  Windows version                  */
    schedule_interval;                  /*  Interval to check new request    */
XML_ITEM
   *config = NULL;

/*- Function prototypes -----------------------------------------------------*/

void WINAPI  service_main        (int argc, char **argv);
void         service_start       (int argc, char **argv);
void         service_stop        (void);
void WINAPI  service_control     (DWORD control_code);
void         install_service     (void);
void         remove_service      (void);
void         console_service     (int argc, char **argv);
BOOL WINAPI  control_handler     (DWORD control_type);
static char *get_last_error_text (char *buffer, int size);
static int   get_windows_version (void);
static long  set_win95_service   (BOOL add);
static BOOL  report_status       (DWORD state, DWORD exit_code, DWORD wait_hint);
static void  add_to_message_log  (char *message);
static void  check_new_request   (void);
static void  load_config_file    (char *file_name);
static void  free_resources      (void);
static void  hide_window         (void);
.if esl.unicode ?= 1
static char *convert_unicode     (UCODE *from, char *charset);
.endif
/*  ---------------------------------------------------------------------[<]-
    Function: main

    Synopsis: Main service function
    ---------------------------------------------------------------------[>]-*/

int
main (int argc, char **argv)
{
    static char
        buffer [LINE_MAX];
    int
        argn;                           /*  Argument number                  */
    char
        *p_char;

    SERVICE_TABLE_ENTRY 
        dispatch_table [] = {
        { NULL, (LPSERVICE_MAIN_FUNCTION) service_main },
        { NULL, NULL }
    };

    /*  Change to the correct working directory                              */
    GetModuleFileName (NULL, buffer, LINE_MAX);
    if ((p_char = strrchr (buffer, '\\\\')) != NULL)
        *p_char = '\\0';
    SetCurrentDirectory (buffer);

    /*  Load configuration data, if any, into the config table               */
    load_config_file ("$(name).xml");

    dispatch_table [0].lpServiceName = service_name;
    win_version = get_windows_version ();

    for (argn = 1; argn < argc; argn++)
      {
        if (*argv [argn] == '-')
          {
            switch (argv [argn][1])
              {
                case 'h':
                    puts (USAGE);
                    return (0);
                /*  These switches take a parameter                          */
                case 'i':
                    if (win_version == WINDOWS_95)
                        set_win95_service (TRUE);
                    else
                        install_service ();
                    return (0);
                case 'u':
                    if (win_version == WINDOWS_95)
                        set_win95_service (FALSE);
                    else
                        remove_service ();
                    return (0);
                case 'd':
                    console_mode  = TRUE;
                    console_service (argc, argv);
                    return (0);
              }
          }
      }
    if (debug_mode)
        coprintf ("Start service... (%s version %s)",
                  APPLICATION_NAME,
                  APPLICATION_VERSION);

    if (win_version == WINDOWS_95)
      {
        hide_window ();
        console_mode = TRUE;
        console_service (argc, argv);
      }
    else
    if (win_version == WINDOWS_NT_3X
    ||  win_version == WINDOWS_NT_4
    ||  win_version == WINDOWS_2000)
      {
        printf ("\\n%s: initialising service dispatcher...", APPLICATION_NAME);
        if (!StartServiceCtrlDispatcher (dispatch_table))
            add_to_message_log ("StartServiceCtrlDispatcher failed");
      }
	return (0);
}


/*  ---------------------------------------------------------------------[<]-
    Function: service_main

    Synopsis: This routine performs the service initialization and then calls
              the user defined service_start() routine to perform majority
              of the work.
    ---------------------------------------------------------------------[>]-*/

void WINAPI
service_main (int argc, char **argv)
{
    /* Register our service control handler:                                 */
    service_status_handle 
        = RegisterServiceCtrlHandler (service_name, service_control);
    if (!service_status_handle)
        return;

    service_status.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    service_status.dwServiceSpecificExitCode = 0;

    /* report the status to the service control manager.                     */
    if (report_status (
            SERVICE_START_PENDING,      /*  Service state                    */
            NO_ERROR,                   /*  Exit code                        */
            3000))                      /*  Wait Hint                        */
        service_start (argc, argv);

    /* Try to report the stopped status to the service control manager.      */
    if (service_status_handle)
        report_status (SERVICE_STOPPED, error_code, 0);
}


/*  ---------------------------------------------------------------------[<]-
    Function: service_start

    Synopsis: Main routine for xitami web server. The service stops when
    server_stop_event is signaled.
    ---------------------------------------------------------------------[>]-*/

void
service_start (int argc, char **argv)
{
    int
        argn;                           /*  Argument number                  */
    Bool
        args_ok     = TRUE,             /*  Were the arguments okay?         */
        quite_mode  = FALSE;            /*  -q means suppress all output     */
    char
        **argparm = NULL;               /*  Argument parameter to pick-up    */
    DWORD
        wait;

    if (debug_mode)
        coprintf ("Check argument value (nb = %d)", argc);

    argparm = NULL;
    for (argn = 1; argn < argc; argn++)
      {
        /*  If argparm is set, we have to collect an argument parameter      */
        if (argparm)
          {
            if (*argv [argn] != '-')    /*  Parameter can't start with '-'   */
              {
                free (*argparm);
                *argparm = strdupl (argv [argn]);
                argparm = NULL;
              }
            else
              {
                args_ok = FALSE;
                break;
              }
          }
        else
        if (*argv [argn] == '-')
          {
            switch (argv [argn][1])
              {
                /*  These switches have an immediate effect                  */
                case 'q':
                    quite_mode = TRUE;
                    break;
                /*  Used only for service                                    */
                case 'i':
                case 'd':
                case 'u':
                case 'v':
                case 'h':
                    break;
                /*  Anything else is an error                                */
                default:
                    args_ok = FALSE;
              }
          }
        else
          {
            args_ok = FALSE;
            break;
          }
      }

    /*  If there was a missing parameter or an argument error, quit          */
    if (argparm)
      {
        add_to_message_log ("Argument missing - type '$(name) -h' for help");
        return;
      }
    else
    if (!args_ok)
      {
        add_to_message_log ("Invalid arguments - type '$(name) -h' for help");
        return;
      }
    /* Service initialization                                                */

    /* Report the status to the service control manager.                     */
    if (!report_status (
            SERVICE_START_PENDING,      /* Service state                     */
            NO_ERROR,                   /* Exit code                         */
            3000))                      /* wait hint                         */
        return;

    /* Create the event object. The control handler function signals         */
    /* this event when it receives the "stop" control code.                  */
    server_stop_event = CreateEvent (
                            NULL,       /* no security attributes            */
                            TRUE,       /* manual reset event                */
                            FALSE,      /* not-signalled                     */
                            NULL);      /* no name                           */

    if (server_stop_event == NULL)
        return;

    /* report the status to the service control manager.                     */
    if (!report_status (
            SERVICE_START_PENDING,      /* Service state                     */
            NO_ERROR,                   /* Exit code                         */
            3000))                      /* wait hint                         */
      {
        CloseHandle (server_stop_event);
        return;
      }
    if (quite_mode)
      {
        fclose (stdout);                /*  Kill standard output             */
        fclose (stderr);                /*   and standard error              */
      }
    /*  Report the status to the service control manager.                    */
    if (!report_status (SERVICE_RUNNING, NO_ERROR, 0))                
      {
        CloseHandle (server_stop_event);
        return;
      }

    if (debug_mode && run_mode == FALSE)
        coprintf ("Run is Off, no database check");
    while (!control_break)
      {
         if (run_mode)
             check_new_request ();           
         wait = WaitForSingleObject (server_stop_event, schedule_interval);
         if (wait != WAIT_TIMEOUT)
            control_break = TRUE;
         else
         if (xml_changed (config))
           {
             load_config_file ("$(name).xml");
             if (debug_mode)
               {
                 if (run_mode == FALSE)
                     coprintf ("Run is Off, no database check");
                  else
                     coprintf ("Run is On,  database checked");
               }
           }
      }
    CloseHandle (server_stop_event);

    free_resources ();
}


/*  ---------------------------------------------------------------------[<]-
    Function: service_stop

    Synopsis: Stops the service. If a service_stop procedure is going to
    take longer than 3 seconds to execute, it should spawn a thread to
    execute the stop code, and return.  Otherwise, ServiceControlManager
    will believe that the service has stopped responding.
    ---------------------------------------------------------------------[>]-*/

void
service_stop (void)
{
    if (server_stop_event)
        SetEvent (server_stop_event);
}


/*  ---------------------------------------------------------------------[<]-
    Function: service_control

    Synopsis: This function is called by the service control manager whenever
              ControlService() is called on this service.
    ---------------------------------------------------------------------[>]-*/

void WINAPI
service_control (DWORD control_code)
{
    /* Handle the requested control code.                                    */
    switch (control_code)
      {
        case SERVICE_CONTROL_STOP:      /*  Stop the service                 */
            service_status.dwCurrentState = SERVICE_STOP_PENDING;
            service_stop ();
            break;

        case SERVICE_CONTROL_INTERROGATE:/* Update the service status        */
            break;
        default:                        /*  Invalid control code             */
            break;
      }
    report_status (service_status.dwCurrentState, NO_ERROR, 0);
}


/*  ---------------------------------------------------------------------[<]-
    Function: report_status

    Synopsis: Sets the current status of the service and
              reports it to the Service Control Manager.
    ---------------------------------------------------------------------[>]-*/

static BOOL
report_status (DWORD state, DWORD exit_code, DWORD wait_hint)
{
    static DWORD
        check_point = 1;
    BOOL
       result       = TRUE;

    /*  when debugging we don't report to the SCM                            */
    if (!console_mode)
      {
        if (state == SERVICE_START_PENDING)
            service_status.dwControlsAccepted = 0;
        else
            service_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        service_status.dwCurrentState  = state;
        service_status.dwWin32ExitCode = exit_code;
        service_status.dwWaitHint      = wait_hint;

        if (state == SERVICE_RUNNING
        ||  state == SERVICE_STOPPED)
            service_status.dwCheckPoint = 0;
        else
            service_status.dwCheckPoint = check_point++;


        /* Report the status of the service to the service control manager.  */
        result = SetServiceStatus (service_status_handle, &service_status);
        if (!result)
            add_to_message_log ("SetServiceStatus");
      }
    return result;
}


/*  ---------------------------------------------------------------------[<]-
    Function: add_to_message_log

    Synopsis: Allows any thread to log an error message.
    ---------------------------------------------------------------------[>]-*/

static void
add_to_message_log (char *message)
{
    static char
        *strings       [2],
        message_buffer [LINE_MAX + 1];
    HANDLE
        event_source_handle;

    if (!console_mode)
      {
        error_code = GetLastError();

        /* Use event logging to log the error.                               */
        event_source_handle = RegisterEventSource (NULL, service_name);

        sprintf (message_buffer, "%s error: %d", service_name, error_code);
        strings [0] = message_buffer;
        strings [1] = message;

        if (event_source_handle)
          {
            ReportEvent (event_source_handle,/* handle of event source       */
                EVENTLOG_ERROR_TYPE,         /* event type                   */
                0,                           /* event category               */
                0,                           /* event ID                     */
                NULL,                        /* current user's SID           */
                2,                           /* strings in variable strings  */
                0,                           /* no bytes of raw data         */
                strings,                     /* array of error strings       */
                NULL);                       /* no raw data                  */

            DeregisterEventSource (event_source_handle);
        }
    }
}


/*  ---------------------------------------------------------------------[<]-
    Function: install_service

    Synopsis: Installs the service
    ---------------------------------------------------------------------[>]-*/

void
install_service (void)
{
    SC_HANDLE
        service,
        manager;
    static char
        path [512];

    if (GetModuleFileName( NULL, path, 512 ) == 0)
      {
        printf ("%s: cannot install '%s': %s\\n",
                 APPLICATION_NAME, service_name, 
                 get_last_error_text (error_buffer, LINE_MAX));
        return;
      }

    manager = OpenSCManager(
                    NULL,                      /* machine  (NULL == local)   */
                    NULL,                      /* database (NULL == default) */
                    SC_MANAGER_ALL_ACCESS      /* access required            */
                );
    if (manager)
      {
        service = CreateService (
                    manager,                   /* SCManager database         */
                    service_name,              /* Short name for service     */
                    service_text,              /* Name to display            */
                    SERVICE_ALL_ACCESS,        /* desired access             */
                    SERVICE_WIN32_OWN_PROCESS, /* service type               */
                    SERVICE_AUTO_START,        /* start type                 */
                    SERVICE_ERROR_NORMAL,      /* error control type         */
                    path,                      /* service's binary           */
                    NULL,                      /* no load ordering group     */
                    NULL,                      /* no tag identifier          */
                    DEPENDENCIES,              /* dependencies               */
                    NULL,                      /* LocalSystem account        */
                    NULL);                     /* no password                */

        if (service)
          {
            printf ("%s: service '%s' installed\\n",
                     APPLICATION_NAME, service_name);
            CloseServiceHandle (service);
          }
        else
            printf ("%s: CreateService '%s' failed: %s\\n", 
                    APPLICATION_NAME, service_name,
                    get_last_error_text (error_buffer, LINE_MAX));

        CloseServiceHandle (manager);
      }
    else
        printf ("%s: OpenSCManager failed: %s\\n",
                APPLICATION_NAME, 
                get_last_error_text (error_buffer, LINE_MAX));
}


/*  ---------------------------------------------------------------------[<]-
    Function: remove_service

    Synopsis: Stops and removes the service
    ---------------------------------------------------------------------[>]-*/

void
remove_service (void)
{
    SC_HANDLE
        service,
        manager;

    manager = OpenSCManager(
                        NULL,                  /* machine (NULL == local)    */
                        NULL,                  /* database (NULL == default) */
                        SC_MANAGER_ALL_ACCESS  /* access required            */
                        );
    if (manager)
      {
        service = OpenService (manager, service_name, SERVICE_ALL_ACCESS);
        if (service)
          {
            /*  Try to stop the service                                      */
            if (ControlService (service, SERVICE_CONTROL_STOP, 
                &service_status))
              {
                printf ("%s: stopping service '%s'...",
                         APPLICATION_NAME, service_name);
                sleep (1);

                while (QueryServiceStatus (service, &service_status))
                    if (service_status.dwCurrentState == SERVICE_STOP_PENDING)
                      {
                        printf (".");
                        sleep  (1);
                      }
                    else
                        break;

                if (service_status.dwCurrentState == SERVICE_STOPPED)
                    printf (" Ok\\n");
                else
                    printf (" Failed\\n");
              }

            /*  Now remove the service                                       */
            if (DeleteService (service))
                printf ("%s: service '%s' removed\\n",
                         APPLICATION_NAME, service_name);
            else
                printf ("%s: DeleteService '%s' failed: %s\\n",
                         APPLICATION_NAME, service_name,
                         get_last_error_text (error_buffer, LINE_MAX));

            CloseServiceHandle (service);
          }
        else
            printf ("%s: OpenService '%s' failed: %s\\n",
                     APPLICATION_NAME, service_name,
                     get_last_error_text (error_buffer, LINE_MAX));

        CloseServiceHandle (manager);
    }
    else
        printf ("%s: OpenSCManager failed: %s\\n",
                 APPLICATION_NAME,
                 get_last_error_text (error_buffer, LINE_MAX));
}


/*  ---------------------------------------------------------------------[<]-
    Function: console_service

    Synopsis: Runs the service as a console application
    ---------------------------------------------------------------------[>]-*/

void
console_service (int argc, char ** argv)
{
    printf ("%s: starting in console mode\\n", APPLICATION_NAME);
    SetConsoleCtrlHandler (control_handler, TRUE);
    service_start (argc, argv);
    control_break = FALSE;
}


/*  ---------------------------------------------------------------------[<]-
    Function: control_handler

    Synopsis: Handled console control events
    ---------------------------------------------------------------------[>]-*/

BOOL WINAPI
control_handler (DWORD control_type)
{
    switch (control_type)
      {
        /* Use Ctrl+C or Ctrl+Break to simulate SERVICE_CONTROL_STOP in      */
        /* console mode                                                      */
        case CTRL_BREAK_EVENT:
        case CTRL_C_EVENT:
            service_stop ();
            printf ("%s: stopping service\\n", APPLICATION_NAME);
            control_break = TRUE;
            return (TRUE);

      }
    return (FALSE);
}


/*  ---------------------------------------------------------------------[<]-
    Function: get_last_error_text

    Synopsis: copies error message text to string
    ---------------------------------------------------------------------[>]-*/

static char *
get_last_error_text (char *buffer, int size)
{
    DWORD
        return_code;
    char
        *temp = NULL;

    return_code = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM     |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 NULL,
                                 GetLastError (),
                                 LANG_NEUTRAL,
                                 (LPTSTR) &temp,
                                 0,
                                 NULL );

    /*  Supplied buffer is not long enough                                    */
    if (return_code == 0 || ((long) size < (long) return_code + 14))
        buffer [0] = '\\0';
    else
      {
        temp [lstrlen (temp) - 2] = '\\0'; /*remove cr and newline character  */
        sprintf (buffer, "%s (0x%x)", temp, GetLastError ());
      }
    if (temp)
        LocalFree ((HLOCAL) temp);

    return (buffer);
}


/*  ---------------------------------------------------------------------[<]-
    Function: get_windows_version

    Synopsis: Return the windows version
    <TABLE>
    WINDOWS_95       Windows 95 or later
    WINDOWS_NT_3X    Windows NT 3.x
    WINDOWS_NT_4     Windows NT 4.0
    WINDOWS_2000     Windows 2000
    </TABLE>
    ---------------------------------------------------------------------[>]-*/

static int
get_windows_version (void)
{
    static int
        version = 0;
    OSVERSIONINFO
        version_info;

    version_info.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx (&version_info))
      {
        if (version_info.dwMajorVersion < 4)
            version = WINDOWS_NT_3X;
        else
        if (version_info.dwPlatformId == VER_PLATFORM_WIN32_NT)
          {
            if (version_info.dwMajorVersion = 4)
                version = WINDOWS_NT_4;
            else
                version = WINDOWS_2000;
          }
        else
            version = WINDOWS_95;
      }
    return (version);
}


/*  ---------------------------------------------------------------------[<]-
    Function: set_win95_service

    Synopsis: Add or remove from the windows registry the value to run
              the web server on startup.
    ---------------------------------------------------------------------[>]-*/

static long
set_win95_service (BOOL add)
{
    HKEY
        key;
    DWORD
        disp;
    long
        feedback;
    static char
        path [LINE_MAX + 1];

    feedback = RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGISTRY_RUN, 
        0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &key, &disp);

    if (feedback == ERROR_SUCCESS)
      {
        if (add)
          {
            GetModuleFileName (NULL, path, LINE_MAX);
            feedback = RegSetValueEx (key, "$(name)", 0, REG_SZ,
                                     (CONST BYTE *) path, strlen (path) + 1);
            coprintf ("$(name): service '%s' installed", service_name);
            coputs   ("Restart windows to run service...");
          }
        else
          {
            feedback = RegDeleteValue (key, "$(name)");
            coprintf ("Updater: service '%s' uninstalled", service_name);
          }
        RegCloseKey (key);
      }
    return (feedback);
}


static void
load_config_file (char *file_name)
{
    XML_ITEM
        *root,
        *item = NULL;
    XML_ATTR
        *attr = NULL;

    if (config)
      {
        xml_free (config);
        config = NULL;
      }

    xml_load_file (&config, ".", file_name, FALSE);
    if (config == NULL)
      {
        coprintf ("Error on load config file!");
        return;
      }

    root = xml_first_child (config);
    FORCHILDREN (item, root)
      {
        if (streq (xml_item_name (item), "main"))
          {
            run_mode    = (Bool)atoi (xml_get_attr (item, "run",   "1"));
            debug_mode  = (Bool)atoi (xml_get_attr (item, "debug", "0"));
            schedule_interval = atoi (xml_get_attr (item, "schedule", "10"));
            schedule_interval *= 1000;
            strcpy (trace_file,   xml_get_attr (item, "trace_file",  "$(name).log"));
            strcpy (service_name, xml_get_attr (item, "service_name", SERVICE_NAME));
            strcpy (service_text, xml_get_attr (item, "service_text", SERVICE_TEXT));
          }
        else
        if (streq (xml_item_name (item), "email"))
          {
            strcpy (sender,       xml_get_attr (item, "sender",      ""));
            strcpy (smtp_server,  xml_get_attr (item, "server",      ""));
            strcpy (user_cc,      xml_get_attr (item, "cc",          ""));
            strcpy (user_bcc,     xml_get_attr (item, "bcc",         ""));
            strcpy (user_to,      xml_get_attr (item, "to",          ""));
          }
        else
        if (streq (xml_item_name (item), "database"))
          {
            strcpy (dbname,       xml_get_attr (item, "dsn",      ""));
            strcpy (dbuser,       xml_get_attr (item, "user",     ""));
            strcpy (dbpwd,        xml_get_attr (item, "password", ""));
          }
      }

    if (debug_mode)
      {
        console_capture  (trace_file, 'a');
        console_set_mode (CONSOLE_DATETIME);
        console_enable   ();
        coputs ("Configuration is loaded"); 
      }
} 

/*  ---------------------------------------------------------------------[<]-
    Function: free_resource

    Synopsis: Free all allocated resources
    ---------------------------------------------------------------------[>]-*/

static void  
free_resources (void)
{
    FILE
        *trace_f = NULL;

    /* Close trace file                                                      */
    if (debug_mode)
       console_capture (NULL, 'a');

    /*  Deallocate configuration symbol table                                */
    if (config)
      {
        xml_free (config);
        config = NULL;
      }

    /*  Check that all memory was cleanly released                           */
    if (mem_used ())
      {
        add_to_message_log ("Memory leak error, see 'memtrace.lst'");
        trace_f = fopen ("memtrace.lst", "w");
        if (trace_f)
          {
            mem_display (trace_f);
            fclose (trace_f);
          }
      }
}

/*  ---------------------------------------------------------------------[<]-
    Function: check_new_request

    Synopsis: Check for new email to send.
    ---------------------------------------------------------------------[>]-*/

static void
check_new_request (void)
{
    $(NAME)QUEUE
        *req;
    $(NAME)LOG
        email_log;
    SMTP
        smtp;
    int
        index,
        feedback;
    char
        message [1024];
    long
        rec_count;
.if esl.unicode ?= 1
    char
        *body       = NULL,
        *subject    = NULL,
        *recipients = NULL,
        *charset    = NULL,
        *from       = NULL,
        *reply      = NULL,
        *msg        = NULL;
    long
        codepage;
    UCODE
        *tmp;
    Bool
        utf_format = FALSE;
.endif

    if (debug_mode)
        coputs ("Check new request in email queue");

    memset (&email_log, 0, sizeof ($(NAME)LOG));

    if (debug_mode)
        coprintf ("Try connection to %s ODBC data source...", dbname);
    if ($(name)_connect (dbname, dbuser, dbpwd))
      {
        if (debug_mode)
            coputs ("Connected :-)");

        rec_count = $(name)queue_get_all (gmtimestamp_now (), &req);
        if (debug_mode)
            coprintf ("Have %ld request in queue", rec_count);
        for (index = 0; index < rec_count &&  control_break == FALSE; index++)
          {
.for queue
.  for table
.    for field where role ?= "logid"
.        logid = realname
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "id"
            email_log.$(realname) = req [index].$(logid);
.    endfor
.  endfor
.endfor
            feedback = $(name)log_get (&email_log);
            if (feedback == OK)
              {
.if esl.unicode ?= 1
.for log
.  for table
.    for field where role ?= "codepage"
                codepage = email_log.$(realname);
                if (codepage == 0)
                    codepage = 1252;
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "charset"
                if (*email_log.$(realname)
                &&  wcscmp (email_log.$(realname), L"utf-8") == 0)
                    utf_format = TRUE;
                else
                    utf_format = FALSE;

                if (utf_format)          
                    charset = mem_strdup ("UTF-8");
                else
                if (codepage == 932)
                  {
                    codepage = 50220;
                    charset = mem_strdup ("ISO-2022-JP");
                  }
                else
                    charset  = ucode2ascii (email_log.$(realname));
.    endfor
.  endfor
.endfor               
.endif

                memset (&smtp, 0, sizeof (SMTP));
                smtp.strSmtpServer       = smtp_server;
.for log
.  for table
.    for field where role ?= "body"
.      if esl.unicode ?= 1
                /* Convert body of message                                    */
                body = convert_unicode (email_log.$(realname), charset);
                smtp.strMessageBody      = body;
.      else
                smtp.strMessageBody      = email_log.$(realname);
.      endif
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "subject"
.      if esl.unicode ?= 1
                subject = convert_unicode (email_log.$(realname), charset);
                smtp.strSubject          = subject;
.      else
                smtp.strSubject          = email_log.$(realname);
.      endif
.    endfor
.  endfor
.endfor
                /* Set sender address                                        */
.for log
.  for table
.    if count (field, role ?= "sender") = 0
                smtp.strSenderUserId     = sender;
.    else
.      for field where role ?= "sender"
.        if esl.unicode ?= 1
                from = convert_unicode (email_log.$(realname), charset);
                if (from && *from)
                    smtp.strSenderUserId     = from;
                else
                    smtp.strSenderUserId     = sender;
.        else
                if (email_log.$(realname) && *email_log.$(realname))
                    smtp.strSenderUserId     = email_log.$(realname);
                else
                    smtp.strSenderUserId     = sender;
.        endif
.      endfor
.    endif
.  endfor
.endfor
                smtp.strFullSenderUserId = "";
                if (user_to && *user_to)
                    smtp.strDestUserIds  = user_to;
                else
.for log
.  for table
.    for field where role ?= "recipients"
.      if esl.unicode ?= 1
                  {
                    recipients = convert_unicode (email_log.$(realname), charset);
                    smtp.strDestUserIds      = recipients;
                  }
.      else
                    smtp.strDestUserIds      = email_log.$(realname);
.      endif
.    endfor
.  endfor
.endfor
                smtp.strFullDestUserIds  = "";
.for log
.  for table
.    if count (field, role ?= "reply") = 0
                smtp.strRetPathUserId    = sender;
.    else
.      for field where role ?= "reply"
.        if esl.unicode ?= 1
                reply = convert_unicode (email_log.$(realname), charset);
                if (reply && *reply)
                    smtp.strRetPathUserId    = reply;
                else
                    smtp.strRetPathUserId    = sender;
.        else
                if (email_log.$(realname) && *email_log.$(realname))
                    smtp.strRetPathUserId    = email_log.$(realname);
                else
                    smtp.strRetPathUserId    = sender;
.        endif
.      endfor
.    endif
.  endfor
.endfor
                smtp.strMsgComment       = "";
                smtp.strMailerName       = "$(description:)";
.if esl.unicode ?= 1
                smtp.strCharSet          = charset;
.endif
                if (user_cc && *user_cc)
                    smtp.strCcUserIds = user_cc;
                if (user_bcc && *user_bcc)
                    smtp.strBccUserIds = user_bcc;
                smtp.connect_retry_cnt   = 3;
                feedback = smtp_send_mail_ex (&smtp);
                if (feedback != SMTP_NO_ERROR)

                  {
                    /* Delete reqest from database                           */
                    $(name)queue_delete (&req [index]);
.for log
.  for table
.    for field where role ?= "status"
                    email_log.$(realname) = 4;
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "sendat"
                    email_log.$(realname) = gmtimestamp_now ();
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "message"
.      if esl.unicode ?= 1
                    sprintf (message, "Send email error: %s",
                             smtp_error_description (feedback));
                    tmp = ascii2ucode (message);
                    if (tmp)
                      {
                        wcscpy (email_log.$(realname), tmp);
                        mem_free (tmp);
                      }             
.      else
                    sprintf (email_log.$(realname), "Send email error: %s",
                             smtp_error_description (feedback));
.      endif
.    endfor
.  endfor
.endfor
                    feedback = $(name)log_update (&email_log);
                    if (feedback != OK)
                      {
                        sprintf (message, "Error on update email log: %s",
                                           $(name)_error_message ());                
                        add_to_message_log (message);
                        service_stop ();
                        control_break = TRUE;
                        break;
                      }
.for log
.  for table
.    for field where role ?= "message"
                    if (debug_mode)
.      if esl.unicode ?= 1
                      {
                        msg = ucode2ascii (email_log.$(realname));
                        if (msg)
                          {
                            coprintf ("SMTP error %s", msg);
                            mem_strfree (&msg);
                          }
                      }                    
.      else
                        coprintf ("SMTP error %s", email_log.$(realname));
.      endif
.    endfor
.  endfor
.endfor
                  }
                else
                  {
.for log
.  for table
.    for field where role ?= "status"
                    email_log.$(realname) = 2;
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "sendat"
                    email_log.$(realname) = gmtimestamp_now ();
.    endfor
.  endfor
.endfor
                    if ($(name)log_update (&email_log) == OK)
                        $(name)queue_delete (&req [index]);
                    else
                      {
                        sprintf (message, "Error on update email log: %s",
                                           $(name)_error_message ());                
                        add_to_message_log (message);
                        service_stop ();
                        control_break = TRUE;
                        break;
                      }
                    if (debug_mode)
                      {
.for log
.  for table
.    for field where role ?= "sendat"
                        long date = timestamp_date (email_log.$(realname));
                        long time = timestamp_time (email_log.$(realname));
.    endfor
.  endfor
.endfor
                        gmt_to_local (date, time, &date, &time);
                        coprintf ("Email send at %s %s to %s, subject: %s",
                                   conv_date_pict (date, "yyyy/mm/dd"),
                                   conv_time_pict (time, "hh:mm:ss"),
.for log
.  for table
.    for field where role ?= "recipients"
.      if esl.unicode ?= 1
                                   recipients,
.      else
                                   email_log.$(realname),
.      endif
.    endfor
.  endfor
.endfor
.for log
.  for table
.    for field where role ?= "subject"
.      if esl.unicode ?= 1
                                   subject);
.      else
                                   email_log.$(realname));
.      endif
.    endfor
.  endfor
.endfor
                      }
                  }
.if esl.unicode ?= 1
                mem_strfree (&body);
                mem_strfree (&subject);
                mem_strfree (&recipients);
                mem_strfree (&charset);
                mem_strfree (&from);
                mem_strfree (&reply);
.endif
              }
          }
        if (debug_mode)
            coputs ("Disconnected");
        $(name)_disconnect ();
      }
    else
        add_to_message_log ("I can't connect to database: Check database parameters!");

    if (rec_count > 0 && req)
        mem_free (req);
}


/*  ---------------------------------------------------------------------[<]-
    Function: hide_window

    Synopsis: Hidden console window.
    ---------------------------------------------------------------------[>]-*/

static void
hide_window (void)
{
    char
        title [255];
    HWND
        win;
    GetConsoleTitle  (title, 254);
    win = FindWindow (NULL,title);
    if (win)
        SetWindowPos (win, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW);
}

.if esl.unicode ?= 1

static char *
convert_unicode (UCODE *from, char *charset)
{
    iconv_t
        cd;
    char
        buffer [256],
        *from_ptr,
        *to_ptr,
        *to = NULL;
    size_t
        return_size,
        from_size,
        to_size;

    from_size = wcslen(from) * 2;
    to_size   = from_size * 3;

    to = mem_alloc (to_size + 1);
    if (to)
      {
        memset (to, 0, to_size + 1);
        from_ptr = (char *)from;
        to_ptr   = to;
        strcpy (buffer, charset);
        if (lexcmp (charset, "ISO-2022-JP") == 0)
            strcat (buffer, "-2");
        cd = iconv_open (buffer, "UNICODELITTLE");
        iconv (cd, NULL, NULL, NULL, NULL);
        
        return_size = iconv (cd, (const char**)&from_ptr, &from_size,
                             &to_ptr, &to_size);
        iconv_close (cd);
      }
    return (to);
}
.endif
.close

.#############################################################################
.## Generate a dummy config file if not exist
.if !exists ("$(name).xml")
.  output "$(name).xml"
.  echo "Create $(name).xml..."
<?xml version="1.0"?>
<config description = "$(description:) configuration">
    <main
        run          = "1"
        schedule     = "30"
        service_name = "$(name)"
        service_text = "$(description:)"
        debug        = "1"
        trace_file   = "$(name).log"
    />
    <email
        sender = "sender@mycompany.com"
        server = "smtp.mycompany.com"
        cc     = ""
        bcc    = ""
        to     = ""
    />
    <database
        dsn      = "apdb"
        user     = "sa"
        password = ""
    />
</config>
.  close
.endif
.endmacro

#############################################################################
########################## L O C A L  M A C R O #############################
#############################################################################

.macro declare_field (pointer, header)
.    if type = "numeric"
.        if decimal ?<> 0  | size ?> 9
    double $(header)$(field.realname);
.        else
    long   $(header)$(field.realname);
.        endif   
.    elsif type = "textual"
.        if (pointer)
.          if esl.unicode ?= 1
    UCODE  *$(header)$(field.realname);
.          else
    char  *$(header)$(field.realname);
.          endif
.        else
.          if esl.unicode ?= 1
    UCODE   $(header)$(field.realname) [$(size) + 1];
.          else
    char   $(header)$(field.realname) [$(size) + 1];
.          endif
.        endif
.    elsif type = "date"
    long   $(header)$(field.realname);
.    elsif type = "time"
    long   $(header)$(field.realname);
.    elsif type = "timestamp"
    double $(header)$(field.realname);
.    elsif type = "boolean"
    short  $(header)$(field.realname);
.    else
.        if esl.unicode ?= 1
    UCODE  *$(header)$(field.realname);
.        else
    char  *$(header)$(field.realname);
.        endif
.    endif
.endmacro

.macro set_default_value (pointer, header)
.    if type = "numeric"
.        if decimal ?<> 0  | size ?> 9
    $(header)$(field.realname)  = 0.0;
.        else
    $(header)$(field.realname)  = 0;
.        endif   
.    elsif type = "textual"
.        if pointer
.            if esl.unicode ?= 1
    $(header)$(field.realname)  = L"";
.            else
    $(header)$(field.realname)  = "";
.            endif
.        else
.            if esl.unicode ?= 1
    *$(header)$(field.realname)  = (UCODE)'\\0';
.            else
    *$(header)$(field.realname)  = '\\0';
.            endif
.        endif
.    elsif type = "date"
    $(header)$(field.realname)  = 0;
.    elsif type = "time"
    $(header)$(field.realname)  = 0;
.    elsif type = "timestamp"
    $(header)$(field.realname)  = 0.0;
.    elsif type = "boolean"
    $(header)$(field.realname)  = FALSE;
.    else
.            if esl.unicode ?= 1
    $(header)$(field.realname)  = L"";
.            else
    $(header)$(field.realname)  = "";
.            endif
.    endif
.endmacro

.macro bind_col (statement)
        rc = SQLBindCol ($(statement), $(bind_index), 
.    if type = "numeric"
.        if decimal ?<> 0  | size ?> 9
                         SQL_C_DOUBLE, &h_$(realname), 0, &indicator);
.        else
                         SQL_C_LONG,   &h_$(realname), 0, &indicator);
.        endif   
.    elsif type = "textual"
.      if esl.unicode ?= 1
                         SQL_C_WCHAR,  &h_$(realname), ($(size) + 1) * UCODE_SIZE, &h_$(realname)_ind);
.      else
                         SQL_C_CHAR,   &h_$(realname), $(size) + 1, &h_$(realname)_ind);
.      endif
.    elsif type = "date"
                         SQL_C_LONG,   &h_$(realname), 0, &indicator);
.    elsif type = "time"
                         SQL_C_LONG,   &h_$(realname), 0, &indicator);
.    elsif type = "timestamp"
                         SQL_C_DOUBLE, &h_$(realname), 0, &indicator);
.    elsif type = "boolean"
                         SQL_C_SHORT,  &h_$(realname), 0, &indicator);
.    else
.      if esl.unicode ?= 1
                         SQL_C_WCHAR,  &h_$(realname), ($(size) + 1) * UCODE_SIZE, &h_$(realname)_ind);
.      else
                         SQL_C_CHAR,   &h_$(realname), $(size) + 1, &h_$(realname)_ind);
.      endif
.    endif
.    bind_index += 1
.endmacro

.macro bind_parameter (statement)
        rc  = SQLBindParameter ($(statement), $(bind_index),             SQL_PARAM_INPUT,
.    if type = "numeric"
.        if decimal ?<> 0  | size ?> 9
                                SQL_C_DOUBLE,  SQL_DOUBLE, 0, 0,
                                &h_$(realname),  0, NULL);
.        else
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_$(realname), 0,NULL);
.        endif   
.    elsif type = "textual"
.      if esl.unicode ?= 1
                                SQL_C_WCHAR,  SQL_WVARCHAR, $(size), 0,
                                h_$(realname),  0, NULL);
.      else
                                SQL_C_CHAR,  SQL_LONGVARCHAR, $(size), 0,
                                h_$(realname),  0, NULL);
.      endif
.    elsif type = "date"
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_$(realname), 0,NULL);
.    elsif type = "time"
                                SQL_C_LONG,  SQL_INTEGER, 0, 0,
                                &h_$(realname), 0,NULL);
.    elsif type = "timestamp"
                                SQL_C_DOUBLE,  SQL_DOUBLE, 0, 0,
                                &h_$(realname),  0, NULL);
.    elsif type = "boolean"
                                SQL_C_SHORT, SQL_INTEGER, 0, 0,
                                &h_$(realname), 0, NULL);
.    else
.      if esl.unicode ?= 1
                                SQL_C_WCHAR,  SQL_WVARCHAR, $(size), 0,
                                h_$(realname),  0, NULL);
.      else
                                SQL_C_CHAR,  SQL_LONGVARCHAR, $(size), 0,
                                h_$(realname),  0, NULL);
.      endif
.    endif
.    bind_index += 1
.endmacro


.macro copy_to_record (rec_name)
.    for field by type
.      if type = "textual"
.        if esl.unicode ?= 1
            if (h_$(realname)_ind < 0)
                *h_$(realname)                       = (UCODE)'\\0';
            else
                h_$(realname) [h_$(realname)_ind / UCODE_SIZE] = (UCODE)'\\0';
            wcscpy ($(rec_name)-> $(realname),    h_$(realname));
.        else
            if (h_$(realname)_ind < 0)
                *h_$(realname)                       = '\\0';
            else
                h_$(realname) [h_$(realname)_ind]    = '\\0';
            strcrop (h_$(realname));
            strcpy ($(rec_name)-> $(realname),    h_$(realname));
.        endif
.      else
            $(rec_name)-> $(realname)     = h_$(realname);
.      endif
.    endfor
.endmacro

if defined (filename)
    load_esl ("$(filename).esl")
    save root as "testout.esl"

    for root.esl
        gen_services    ("$(name).c")
    endfor
else
    echo "Define variable 'filename' before calling this file"
endif